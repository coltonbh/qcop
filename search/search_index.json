{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quantum Chemistry Operate","text":"<p>A package for operating Quantum Chemistry programs using qcio standardized data structures. Compatible with <code>TeraChem</code>, <code>psi4</code>, <code>QChem</code>, <code>NWChem</code>, <code>ORCA</code>, <code>Molpro</code>, <code>geomeTRIC</code> and many more.</p> <p> </p> <p><code>qcop</code> works in harmony with a suite of other quantum chemistry tools for fast, structured, and interoperable quantum chemistry.</p>"},{"location":"#the-qc-suite-of-programs","title":"The QC Suite of Programs","text":"<ul> <li>qcconst - Physical constants, conversion factors, and a periodic table with clear source information for every value.</li> <li>qcio - Elegant and intuitive data structures for quantum chemistry, featuring seamless Jupyter Notebook visualizations.</li> <li>qcinf - Cheminformatics algorithms and structure utilities using standardized qcio data structures.</li> <li>qccodec - A library for efficient parsing of quantum chemistry data into structured <code>qcio</code> objects.</li> <li>qcop - A package for operating quantum chemistry programs using <code>qcio</code> standardized data structures. Compatible with <code>TeraChem</code>, <code>psi4</code>, <code>QChem</code>, <code>NWChem</code>, <code>ORCA</code>, <code>Molpro</code>, <code>geomeTRIC</code>, and many more, featuring seamless Jupyter Notebook visualizations.</li> <li>BigChem - A distributed application for running quantum chemistry calculations at scale across clusters of computers or the cloud. Bring multi-node scaling to your favorite quantum chemistry program, featuring seamless Jupyter Notebook visualizations of your data.</li> <li><code>ChemCloud</code> - A web application and associated Python client for exposing a BigChem cluster securely over the internet, featuring seamless Jupyter Notebook visualizations.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>python -m pip install qcop\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":"<p><code>qcop</code> uses the <code>qcio</code> data structures to drive quantum chemistry programs in a standardized way. This allows for a simple and consistent interface to a wide variety of quantum chemistry programs. See the qcio library for documentation on the input and output data structures.</p> <p>The <code>compute</code> function is the main entry point for the library and is used to run a calculation.</p> <pre><code>from qcio import Structure, CalcSpec\nfrom qcop import compute\nfrom qcop.exceptions import ExternalProgramError\n# Create the Structure\nh2o = Structure.open(\"h2o.xyz\")\n\n# Define the calcspec\nspec = CalcSpec(\n    structure=h2o,\n    calctype=\"energy\",\n    model={\"method\": \"hf\", \"basis\": \"sto-3g\"},\n    keywords={\"purify\": \"no\", \"restricted\": False},\n)\n\n# Run the calculation; will return Results or raise an exception\ntry:\n    result = compute(\"terachem\", spec, collect_files=True)\nexcept ExternalProgramError as e:\n    # External QQ program failed in some way\n    result = e.results\n    result.input_data # Input data used by the QC program\n    result.success # Will be False\n    result.data # Any half-computed results before the failure\n    result.traceback # Stack trace from the calculation\n    result.logs # Logs from the calculation\n    result.ptraceback # Shortcut to print out the traceback in human readable format\n    raise e\nelse:\n    # Calculation succeeded\n    result.input_data # Input data used by the QC program\n    result.success # Will be True\n    result.data # All structured data and files from the calculation\n    result.data.files # Any files returned by the calculation\n    result.logs # Logs from the calculation\n    result.plogs # Shortcut to print out the logs in human readable format\n    result.provenance # Provenance information about the calculation\n    result.extras # Any extra information not in the schema\n</code></pre> <p>One may also call <code>compute(..., raise_exc=False)</code> to return a <code>Results</code> object rather than raising an exception when a calculation fails. This may allow easier handling of failures in some cases.</p> <pre><code>from qcio import Structure, CalcSpec\nfrom qcop import compute\nfrom qcop.exceptions import ExternalProgramError\n# Create the Structure\nh2o = Structure.open(\"h2o.xyz\")\n\n# Define the calcspec\nspec = CalcSpec(\n    structure=h2o,\n    calctype=\"energy\",\n    model={\"method\": \"hf\", \"basis\": \"sto-3g\"},\n    keywords={\"purify\": \"no\", \"restricted\": False},\n)\n\n# Run the calculation; will return a Results object\nresult = compute(\"terachem\", spec, collect_files=True, raise_exc=False)\nif not result.success:\n    # Same as except block above\n\nelse:\n    # Same as else block above\n</code></pre> <p>Alternatively, the <code>compute_args</code> function can be used to run a calculation with the input data structures passed in as arguments rather than as a single <code>CalcSpec</code> object.</p> <pre><code>from qcio import Structure\nfrom qcop import compute_args\n# Create the Structure\nh2o = Structure.open(\"h2o.xyz\")\n\n# Run the calculation\nresult = compute_args(\n    \"terachem\",\n    h2o,\n    calctype=\"energy\",\n    model={\"method\": \"hf\", \"basis\": \"sto-3g\"},\n    keywords={\"purify\": \"no\", \"restricted\": False},\n    files={...},\n    collect_files=True\n)\n</code></pre> <p>The behavior of <code>compute()</code> and <code>compute_args()</code> can be tuned by passing in keyword arguments like <code>collect_files</code> shown above. Arguments can modify which scratch directory location to use, whether to delete or keep the scratch files after a calculation completes, what files to collect from a calculation, whether to stream the program logs in real time as the program executes, and whether to propagate a wavefunction through a series of calculations. Arguments also include hooks for passing in update functions that can be called as a program executes in real time. See the compute method docstring for more details.</p> <p>See the /examples directory for more examples.</p>"},{"location":"#visualization","title":"\u2728 Visualization \u2728","text":"<p>Visualize all your results with a single line of code!</p> <p>First install the visualization module:</p> <pre><code>python -m pip install qcio[view]\n</code></pre> <p>or if your shell requires <code>''</code> around arguments with brackets:</p> <pre><code>python -m pip install 'qcio[view]'\n</code></pre> <p>Then in a Jupyter notebook import the <code>qcio</code> view module and call <code>view.view(...)</code> passing it one or any number of <code>qcio</code> objects you want to visualizing including <code>Structure</code> objects or any <code>Results</code> object. You may also pass an array of <code>titles</code> and/or <code>subtitles</code> to add additional information to the molecular structure display. If no titles are passed <code>qcio</code> with look for <code>Structure</code> identifiers such as a name or SMILES to label the <code>Structure</code>.</p> <p></p> <p>Seamless visualizations for <code>Results</code> objects make results analysis easy!</p> <p></p> <p>Single point calculations display their results in a table.</p> <p></p> <p>If you want to use the HTML generated by the viewer to build your own dashboards use the functions inside of <code>qcio.view.py</code> that begin with the word <code>generate_</code> to create HTML you can insert into any dashboard.</p>"},{"location":"#support","title":"Support","text":"<p>If you have any issues with <code>qcop</code> or would like to request a feature, please open an issue.</p>"},{"location":"examples/conformer_search/","title":"Conformer Search","text":"<pre><code>from qcio import CalcSpec, Structure\n\nfrom qcop import compute, exceptions\n\n# Create the structure\n# Can also open a structure from a file\n# structure = Structure.open(\"path/to/h2o.xyz\")\nstructure = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[  # type: ignore\n        [0.0, 0.0, 0.0],\n        [0.52421003, 1.68733646, 0.48074633],\n        [1.14668581, -0.45032174, -1.35474466],\n    ],\n)\n\n# Define the calcspec\nspec = CalcSpec(\n    structure=structure,\n    calctype=\"conformer_search\",  # type: ignore\n    model={\"method\": \"gfnff\"},  # type: ignore\n    keywords={\"calculation\": {\"level\": [{\"alpb\": \"acetonitrile\"}]}},\n)\n\n# Run the calculation\ntry:\n    # results is instance of Results\n    results = compute(\n        \"crest\", spec, collect_files=True, collect_rotamers=False\n    )\nexcept exceptions.QCOPBaseError as e:\n    results = e.results\n    print(results.logs)\n    print(f\"Success: {results.success}\")  # False\n    print(results.input_data)  # Input data used to generate the calculation\n    print(results.provenance)  # Provenance of generated calculation\n    print(results.traceback)  # or output.ptraceback for short\n    raise\n\nelse:\n    # Check results\n    print(results.logs)\n    print(f\"Success: {results.success}\")  # True\n    print(\"output.data: \", results.data)\n    print(\"output.data.conformer_energies:\", results.data.conformer_energies)\n    print(\n        \"output.data.conformer_energies_relative:\",\n        results.data.conformer_energies_relative,\n    )\n    print(results.input_data)  # Input data used to generate the calculation\n    print(results.provenance)  # Provenance of generated calculation\n</code></pre>"},{"location":"examples/file_input/","title":"File Input","text":"<p>The <code>File Input</code> can be used as an escape hatch when you want to perform a calculation type that is not yet supported by <code>qcop</code> or use a program not yet supported by <code>qcop</code>. You can submit the program's native input files to the program and <code>qcop</code> will execute the program, collect all the outputs, and return them to you. These calculations could be an MD run, some unique calculation type not supported by <code>qcop</code>, or any arbitrary command you can send to any command-line executable program.</p> <pre><code>\"\"\"An example of how to create a FileSpec object for a QC Program.\"\"\"\n\nfrom pathlib import Path\n\nfrom qcio import FileSpec, Structure\n\nfrom qcop import compute\n\n# Input files for QC Program\ninp_file = Path(\"path/to/tc.in\").read_text()  # Or your own function to create tc.in\n\n# Structure object to XYZ file\nstructure = Structure.open(\"path/to/my/mol.xyz\")\nxyz_str = structure.to_xyz()  # type: ignore\n\n# Create a FileSpec object for TeraChem\nspec = FileSpec(\n    files={\"tc.in\": inp_file, \"coords.xyz\": xyz_str}, cmdline_args=[\"tc.in\"]\n)\n\n# This will write the files to disk in a temporary directory and then run\n# \"terachem tc.in\" in that directory.\nresults = compute(\"terachem\", spec, print_logs=True)\n\n# Data\nresults.logs\nresults.input_data\nresults.data.files  # Has all the files terachem creates\nresults.data.files.keys()  # Print out file names\n# Saves all outputs with the exact structure produced by the QC program\nresults.data.save_files(\"to/this/directory\")\n</code></pre>"},{"location":"examples/optimization/","title":"Optimization","text":""},{"location":"examples/optimization/#geometric","title":"geomeTRIC","text":"<pre><code>\"\"\"Example of using geometric subprogram to optimize H2 bond length.\n\nConstraints docs: https://geometric.readthedocs.io/en/latest/constraints.html\n\"\"\"\n\nfrom qcio import CompositeCalcSpec, Structure\n\nfrom qcop import compute, exceptions\n\n# Create Structure\nh2 = Structure(\n    symbols=[\"H\", \"H\"],\n    geometry=[[0, 0.0, 0.0], [0, 0, 1.4]],  # type: ignore\n)\n\n# Define the calcspec\nspec = CompositeCalcSpec(\n    calctype=\"optimization\",  # type: ignore\n    structure=h2,\n    subprogram=\"terachem\",\n    subprogram_spec={  # type: ignore\n        \"model\": {\"method\": \"HF\", \"basis\": \"6-31g\"},\n        \"keywords\": {\"purify\": \"no\"},\n    },\n    keywords={\n        \"check\": 3,\n        # This is obviously a stupid constraint, but it's just an example to show how\n        # to use them\n        \"constraints\": {\n            \"freeze\": [\n                {\"type\": \"distance\", \"indices\": [0, 1], \"value\": 1.4},\n            ],\n        },\n    },\n)\n\n# Run calculation\ntry:\n    results = compute(\"geometric\", spec, propagate_wfn=True, rm_scratch_dir=False)\nexcept exceptions.QCOPBaseError as e:\n    # Calculation failed\n    results = e.results\n    print(results.logs)\n    # Input data used to generate the calculation\n    print(results.input_data)\n    # Provenance of generated calculation\n    print(results.provenance)\n    print(results.traceback)\n    raise\n\nelse:\n    # Check results\n    print(\"Energies:\", results.data.energies)\n    print(\"Structures:\", results.data.structures)\n    print(\"Trajectory:\", results.data.trajectory)\n    # Stdout from the program\n    print(results.logs)\n    # Input data used to generate the calculation\n    print(results.input_data)\n    # Provenance of generated calculation\n    print(results.provenance)\n</code></pre>"},{"location":"examples/optimization/#terachem","title":"TeraChem","text":"<pre><code>\"\"\"Example of how to run an optimization calculation with TeraChem using qcop.\"\"\"\n\nfrom qcio import CalcSpec, Structure\n\nfrom qcop import compute, exceptions\n\n# Create the structure\n# Can also open a structure from a file\n# structure = Structure.open(\"path/to/h2o.xyz\")\nstructure = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[  # type: ignore\n        [0.0, 0.0, 0.0],\n        [0.52421003, 1.68733646, 0.48074633],\n        [1.14668581, -0.45032174, -1.35474466],\n    ],\n)\n\n# Define the calcspec\nspec = CalcSpec(\n    structure=structure,\n    # Can be \"energy\", \"gradient\", \"hessian\", \"optimization\", \"transition_state\"\n    calctype=\"optimization\",  # type: ignore\n    model={\"method\": \"hf\", \"basis\": \"sto-3g\"},  # type: ignore\n    keywords={\"purify\": \"no\", \"new_minimizer\": \"yes\"},  # new_minimizer yes is required\n)\n\n# Run the calculation\ntry:\n    # results is instance of Results\n    results = compute(\"terachem\", spec, collect_files=True)\nexcept exceptions.QCOPBaseError as e:\n    results = e.results\n    print(results.logs)\n    print(f\"Success: {results.success}\")  # False\n    print(results.input_data)  # Input data used to generate the calculation\n    print(results.provenance)  # Provenance of generated calculation\n    print(results.traceback)  # or output.ptraceback for short\n    raise\n\nelse:\n    # Check results\n    print(results.logs)\n    print(f\"Success: {results.success}\")  # True\n    print(\"output.data: \", results.data)\n    print(\"output.data.energies:\", results.data.energies)\n    print(\"output.data.structures:\", results.data.structures)\n    print(\"output.data.final_structure:\", results.data.final_structure)\n    print(results.input_data)  # Input data used to generate the calculation\n    print(results.provenance)  # Provenance of generated calculation\n</code></pre>"},{"location":"examples/overview/","title":"Overview","text":"<p>Calculations are run by calling the <code>qcop.compute()</code> function with the relevant arguments and keywords like this:</p> <pre><code>from qcio import Structure, CalcSpec\nfrom qcop import compute\n\n# Create the Structure\nstructure = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[  # type: ignore\n        [0.0, 0.0, 0.0],\n        [0.52421003, 1.68733646, 0.48074633],\n        [1.14668581, -0.45032174, -1.35474466],\n    ],\n)\n\n# Define the calcspec\nspec = CalcSpec(\n    structure=h2o,\n    calctype=\"energy\",\n    model={\"method\": \"hf\", \"basis\": \"sto-3g\"},\n    keywords={\"purify\": \"no\", \"restricted\": False},\n)\n\n# Run the calculation; will return Results or raise an exception\nresult = compute(\"terachem\", spec, collect_files=True)\n</code></pre> <p>The <code>compute</code> selects the correct program adapter and then calls <code>adapter.compute()</code>. The available arguments and keywords for the top level <code>compute()</code> function match those shown here:</p> <pre><code>\n</code></pre>"},{"location":"examples/overview/#qcop.adapters.BaseAdapter.compute","title":"qcop.adapters.BaseAdapter.compute","text":"<pre><code>compute(input_data: SpecType, *, scratch_dir: StrOrPath | None = None, rm_scratch_dir: bool = True, collect_logs: bool = True, collect_files: bool = False, collect_wfn: bool = False, update_func: Callable | None = None, update_interval: float | None = None, print_logs: bool = False, raise_exc: bool = True, propagate_wfn: bool = False, **adapter_kwargs) -&gt; Results[SpecType, DataType]\n</code></pre> <p>Compute the given input using the adapter's program.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>SpecType</code> <p>A qcio input object for a computation. E.g. A FileSpec, CalcSpec or CompositeCalcSpec.</p> required <code>scratch_dir</code> <code>StrOrPath | None</code> <p>The scratch directory for the program. If None, a new directory is created in the system default temporary directory. If rm_scratch_dir is True this directory will be deleted after the program finishes.</p> <code>None</code> <code>rm_scratch_dir</code> <code>bool</code> <p>Delete the scratch directory after the program exits.</p> <code>True</code> <code>collect_logs</code> <code>bool</code> <p>Whether to collect stdout/stderr from the program as output. Failed computations will always collect stdout/stderr.</p> <code>True</code> <code>collect_files</code> <code>bool</code> <p>Collect all files generated by the QC program as output.</p> <code>False</code> <code>collect_wfn</code> <code>bool</code> <p>Collect the wavefunction file(s) from the calculation. Not every program will support this. Use collect_files to collect all files including the wavefunction.</p> <code>False</code> <code>update_func</code> <code>Callable | None</code> <p>A function to call as the program executes. The function must accept the in-process stdout/stderr output as a string for its first argument.</p> <code>None</code> <code>update_interval</code> <code>float | None</code> <p>The minimum time in seconds between calls to the update_func.</p> <code>None</code> <code>print_logs</code> <code>bool</code> <p>Whether to print stdout/stderr to the terminal in real time as the program executes. Will be ignored if an update_func passed.</p> <code>False</code> <code>raise_exc</code> <code>bool</code> <p>If False, qcop will return a Results object when the QC program fails rather than raise an exception.</p> <code>True</code> <code>propagate_wfn</code> <code>bool</code> <p>For any adapter performing a sequential task, such as a geometry optimization, propagate the wavefunction from the previous step to the next step. This is useful for accelerating convergence by using a previously computed wavefunction as a starting guess. If an adapter does not support wavefunction propagation, an AdapterInputError will be raised.</p> <code>False</code> <code>**adapter_kwargs</code> <p>Additional keyword arguments to pass to the adapter or qcng.compute().</p> <code>{}</code> <p>Returns:</p> Type Description <code>Results[SpecType, DataType]</code> <p>A Results object containing the results of the computation.</p> <p>Raises:</p> Type Description <code>AdapterNotFoundError</code> <p>If the program is not supported (i.e., no Adapter is implemented for the program in qcop or qcengine).</p> <code>ProgramNotFoundError</code> <p>If the program executable is not found on the system at execution time. This likely means the program is not installed or not available on the $PATH.</p> <code>AdapterInputError</code> <p>If the input is invalid for the adapter.</p> <code>ExternalProgramExecutionError</code> <p>If the QC program fails during execution.</p> <code>QCEngineError</code> <p>If QCEngine performs the computation raises an error.</p> Source code in <code>src/qcop/adapters/base.py</code> <pre><code>def compute(\n    self,\n    input_data: SpecType,\n    *,\n    scratch_dir: StrOrPath | None = None,\n    rm_scratch_dir: bool = True,\n    collect_logs: bool = True,\n    collect_files: bool = False,\n    collect_wfn: bool = False,\n    update_func: Callable | None = None,\n    update_interval: float | None = None,\n    print_logs: bool = False,\n    raise_exc: bool = True,\n    propagate_wfn: bool = False,\n    **adapter_kwargs,\n) -&gt; Results[SpecType, DataType]:\n    \"\"\"Compute the given input using the adapter's program.\n\n    Args:\n        input_data: A qcio input object for a computation. E.g. A FileSpec,\n            CalcSpec or CompositeCalcSpec.\n        scratch_dir: The scratch directory for the program. If None, a new directory\n            is created in the system default temporary directory. If rm_scratch_dir\n            is True this directory will be deleted after the program finishes.\n        rm_scratch_dir: Delete the scratch directory after the program exits.\n        collect_logs: Whether to collect stdout/stderr from the program as output.\n            Failed computations will always collect stdout/stderr.\n        collect_files: Collect all files generated by the QC program as output.\n        collect_wfn: Collect the wavefunction file(s) from the calculation.\n            Not every program will support this. Use collect_files to collect\n            all files including the wavefunction.\n        update_func: A function to call as the program executes. The function must\n            accept the in-process stdout/stderr output as a string for its first\n            argument.\n        update_interval: The minimum time in seconds between calls to the\n            update_func.\n        print_logs: Whether to print stdout/stderr to the terminal in real time as\n            the program executes. Will be ignored if an update_func passed.\n        raise_exc: If False, qcop will return a Results object when the QC\n            program fails rather than raise an exception.\n        propagate_wfn: For any adapter performing a sequential task, such\n            as a geometry optimization, propagate the wavefunction from the previous\n            step to the next step. This is useful for accelerating convergence by\n            using a previously computed wavefunction as a starting guess. If an\n            adapter does not support wavefunction propagation, an AdapterInputError\n            will be raised.\n        **adapter_kwargs: Additional keyword arguments to pass to the adapter or\n            qcng.compute().\n\n    Returns:\n        A Results object containing the results of the computation.\n\n    Raises:\n        AdapterNotFoundError: If the program is not supported (i.e., no Adapter\n            is implemented for the program in qcop or qcengine).\n        ProgramNotFoundError: If the program executable is not found on the\n            system at execution time. This likely means the program is not installed\n            or not available on the $PATH.\n        AdapterInputError: If the input is invalid for the adapter.\n        ExternalProgramExecutionError: If the QC program fails during execution.\n        QCEngineError: If QCEngine performs the computation raises an error.\n    \"\"\"\n    # Print stdout to terminal in real time as program executes\n    if print_logs and update_func is None:\n        update_func, update_interval = (\n            lambda _, stdout_new: print(stdout_new),\n            0.1,\n        )\n\n    # cd to a temporary directory to run the program.\n    with tmpdir(self.uses_files, scratch_dir, rm_scratch_dir) as final_scratch_dir:\n        if self.uses_files:  # Write non structured input files to disk.\n            input_data.save_files()\n\n        # Define outputs\n        results_dict: dict[str, Any] = {}\n        logs: str | None = None\n        data: Data\n        exc: QCOPBaseError | None = None\n        program_version: str | None = None\n\n        start = time()\n        try:\n            # Validate input object\n            self.validate_input(input_data)\n\n            # Execute the program. results will be None if FileSpec\n            data, logs = self.compute_data(\n                input_data,\n                update_func,\n                update_interval,\n                propagate_wfn=propagate_wfn,\n                **adapter_kwargs,\n            )\n            # None value covers FileSpec case\n            results_dict[\"success\"] = True\n\n            # Optionally collect wavefunction file\n            if collect_wfn and not collect_files:\n                results_dict[\"files\"] = self.collect_wfn()\n\n        except QCOPBaseError as e:\n            exc = e\n            results_dict[\"success\"] = False\n            # Any half-completed data\n            data = getattr(e, \"data\") or Files()\n            logs = getattr(e, \"logs\", logs) or logs\n            # For mypy because e.logs is not of a known type\n            logs = str(logs) if logs is not None else None\n            results_dict[\"traceback\"] = traceback.format_exc()\n\n        wall_time = time() - start\n\n        # Check for parsed version in extras at default location\n        program_version = data.extras.get(\"program_version\")\n        if not program_version:\n            try:\n                program_version = self.program_version(logs)\n            except ProgramNotFoundError:\n                pass  # program_version = None set above\n\n        # Construct Provenance object\n        provenance = construct_provenance(\n            self.program,\n            program_version,\n            final_scratch_dir,\n            wall_time,\n        )\n\n        # Always collect for failures; otherwise obey collect_logs\n        logs = logs if not results_dict[\"success\"] or collect_logs else None\n\n        # Construct output object\n        results_dict.update(\n            {\n                \"input_data\": input_data,\n                \"logs\": logs,\n                \"data\": data,\n                \"provenance\": provenance,\n            }\n        )\n        results = Results[SpecType, DataType](**results_dict)\n\n        # Collect files generated by the program\n        if self.uses_files and (collect_files or type(input_data) is FileSpec):\n            results.data.add_files(\n                final_scratch_dir,\n                recursive=True,\n                exclude=list(input_data.files.keys()),\n            )\n\n    # Append Results to exception and raise if raise_exc=True\n    # Helpful for BigChem and ChemCloud exception handling\n    if raise_exc and exc:\n        exc.results = results\n        raise exc\n\n    return results\n</code></pre>"},{"location":"examples/single_point/","title":"Single Point","text":"<pre><code>from qcio import CalcSpec, Structure\n\nfrom qcop import compute, exceptions\n\n# Create the structure\n# Can also open a structure from a file\n# structure = Structure.open(\"path/to/h2o.xyz\")\nstructure = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[  # type: ignore\n        [0.0, 0.0, 0.0],\n        [0.52421003, 1.68733646, 0.48074633],\n        [1.14668581, -0.45032174, -1.35474466],\n    ],\n)\n\n# Define the calcspec\nspec = CalcSpec(\n    structure=structure,\n    # Can be \"energy\", \"gradient\", \"hessian\"\n    calctype=\"energy\",  # type: ignore\n    model={\"method\": \"hf\", \"basis\": \"sto-3g\"},  # type: ignore\n    keywords={\"purify\": \"no\"},\n)\n\n# Run the calculation\ntry:\n    # results is instance of Results\n    results = compute(\"terachem\", spec, collect_files=True)\nexcept exceptions.QCOPBaseError as e:\n    results = e.results\n    print(results.logs)\n    print(f\"Success: {results.success}\")  # False\n    print(results.input_data)  # Input data used to generate the calculation\n    print(results.provenance)  # Provenance of generated calculation\n    print(results.traceback)  # or output.ptraceback for short\n    raise\n\nelse:\n    # Check results\n    print(results.logs)\n    print(f\"Success: {results.success}\")  # True\n    print(\"output.data: \", results.data)\n    print(\"output.data.energy:\", results.data.energy)\n    print(\"output.data.gradient:\", results.data.gradient)\n    print(\"output.data.hessian:\", results.data.hessian)\n    print(results.input_data)  # Input data used to generate the calculation\n    print(results.provenance)  # Provenance of generated calculation\n</code></pre>"},{"location":"programs/crest/","title":"CREST","text":"<p>Danger</p> <p>Solvation using CREST's new default runtime, <code>tblite</code>, is current buggy. For details see this issue. According to this comment only <code>gfnff</code> and <code>gfn0</code> work correctly with either <code>alpb</code> or <code>gbsa</code> solvent option. If you want to use solvation you need to use the <code>--legacy</code> mode which uses <code>xtb</code> instead of <code>tblite</code> for the calculation backend. Some progress is being made on this issue in this PR.</p>"},{"location":"programs/crest/#qcop.adapters.crest.CRESTAdapter","title":"qcop.adapters.crest.CRESTAdapter","text":"<p>Adapter for CREST.</p> Note <p>The <code>CalcSpec.keywords</code> attribute is used to create the input file for CREST. This means that the structure of the <code>keywords</code> attribute should match that of CREST's input specification. Keywords such as method, charge, and uhf (which are stored on the <code>Model</code> and <code>Structure</code>; uhf is <code>multiplicity - 1</code>) will be added to the input file automatically.</p> Warning <p>CREST does not exit with a non-zero exit code on failure. Instead, it prints \"FAILED\" in the stdout. This adapter will raise an ExternalProgramError if \"FAILED\" is found in the stdout.</p> Warning <p>CREST automatically translates the input geometry to the origin. This means that the input geometry printed to CREST's stdout will not match the input structure; however, all computed values (such as energies, gradients, etc.) are still valid because they are translationally invariant.</p>"},{"location":"programs/crest/#qcop.adapters.crest.CRESTAdapter.supported_calctypes","title":"supported_calctypes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>supported_calctypes = [energy, gradient, hessian, optimization, conformer_search]\n</code></pre> <p>Supported calculation types.</p>"},{"location":"programs/crest/#qcop.adapters.crest.CRESTAdapter.program_version","title":"program_version","text":"<pre><code>program_version(stdout: str | None = None) -&gt; str\n</code></pre> <p>Get the program version.</p> <p>Parameters:</p> Name Type Description Default <code>stdout</code> <code>str | None</code> <p>The stdout from the program.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The program version.</p> Source code in <code>src/qcop/adapters/crest.py</code> <pre><code>def program_version(self, stdout: str | None = None) -&gt; str:\n    \"\"\"Get the program version.\n\n    Args:\n        stdout: The stdout from the program.\n\n    Returns:\n        The program version.\n    \"\"\"\n    if not stdout:\n        stdout = execute_subprocess(self.program, [\"--version\"])\n    return parse_version(stdout)\n</code></pre>"},{"location":"programs/crest/#qcop.adapters.crest.CRESTAdapter.compute_data","title":"compute_data","text":"<pre><code>compute_data(input_data: CalcSpec, update_func: Callable | None = None, update_interval: float | None = None, collect_rotamers: bool = False, **kwargs) -&gt; tuple[SinglePointData | OptimizationResults | ConformerSearchResults, str]\n</code></pre> <p>Execute CREST on the given input.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>CalcSpec</code> <p>The qcio CalcSpec object for a computation.</p> required <code>update_func</code> <code>Callable | None</code> <p>A function to call with the stdout at regular intervals.</p> <code>None</code> <code>update_interval</code> <code>float | None</code> <p>The interval at which to call the update function.</p> <code>None</code> <code>collect_rotamers</code> <code>bool</code> <p>Collect rotamers if doing a conformer_search. Defaults to False since rotamers are usually not of interest and there will be many.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[SinglePointData | OptimizationResults | ConformerSearchResults, str]</code> <p>A tuple of ConformerSearchResults and the stdout str.</p> Source code in <code>src/qcop/adapters/crest.py</code> <pre><code>def compute_data(\n    self,\n    input_data: CalcSpec,\n    update_func: Callable | None = None,\n    update_interval: float | None = None,\n    collect_rotamers: bool = False,\n    **kwargs,\n) -&gt; tuple[SinglePointData | OptimizationResults | ConformerSearchResults, str]:\n    \"\"\"Execute CREST on the given input.\n\n    Args:\n        input_data: The qcio CalcSpec object for a computation.\n        update_func: A function to call with the stdout at regular intervals.\n        update_interval: The interval at which to call the update function.\n        collect_rotamers: Collect rotamers if doing a conformer_search. Defaults to\n            False since rotamers are usually not of interest and there will be many.\n\n    Returns:\n        A tuple of ConformerSearchResults and the stdout str.\n    \"\"\"\n    # Create CREST native input files\n    try:\n        native_inp = qccodec.encode(input_data, self.program)\n    except qccodec.exceptions.EncoderError as e:\n        raise AdapterInputError(program=self.program) from e\n\n    # Write the input files to disk\n    inp_file, struct_file = Path(\"input.toml\"), Path(native_inp.geometry_filename)\n    inp_file.write_text(native_inp.input_file)\n    struct_file.write_text(native_inp.geometry_file)\n\n    # Execute CREST\n    stdout = execute_subprocess(\n        self.program, [inp_file.name], update_func, update_interval\n    )\n\n    # CREST does not exit with a non-zero exit code on failure\n    if \"FAILED\" in stdout:\n        raise ExternalProgramError(\n            program=self.program,\n            message=f\"CREST calculation failed. See the stdout for more information.\",\n            logs=stdout,\n        )\n\n    # Parse the output\n    try:\n        results = qccodec.decode(\n            self.program,\n            input_data.calctype,\n            stdout=stdout,\n            directory=\".\",\n            input_data=input_data,\n        )\n    except qccodec.exceptions.ParserError as e:\n        raise ExternalProgramError(\n            program=\"qccodec\",\n            message=\"Failed to parse CREST output.\",\n            logs=stdout,\n            original_exception=e,\n        ) from e\n\n    return results, stdout\n</code></pre>"},{"location":"programs/geometric/","title":"geomeTRIC","text":""},{"location":"programs/geometric/#qcop.adapters.geometric.GeometricAdapter","title":"qcop.adapters.geometric.GeometricAdapter","text":"<pre><code>GeometricAdapter()\n</code></pre> <p>Adapter for geomeTRIC.</p> Source code in <code>src/qcop/adapters/geometric.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    # Check that geomeTRIC is installed\n    self.geometric = self._ensure_geometric_installed()\n    # Dictionary from geometric.run_json; copying QCSchema workflow\n    self.coordsys_params = {\n        \"cart\": (self.geometric.internal.CartesianCoordinates, False, False),\n        \"prim\": (self.geometric.internal.PrimitiveInternalCoordinates, True, False),\n        \"dlc\": (\n            self.geometric.internal.DelocalizedInternalCoordinates,\n            True,\n            False,\n        ),\n        \"hdlc\": (\n            self.geometric.internal.DelocalizedInternalCoordinates,\n            False,\n            True,\n        ),\n        \"tric\": (\n            self.geometric.internal.DelocalizedInternalCoordinates,\n            False,\n            False,\n        ),\n    }\n</code></pre>"},{"location":"programs/geometric/#qcop.adapters.geometric.GeometricAdapter.supported_calctypes","title":"supported_calctypes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>supported_calctypes = [optimization, transition_state]\n</code></pre> <p>Supported calculation types.</p>"},{"location":"programs/geometric/#qcop.adapters.geometric.GeometricAdapter.program_version","title":"program_version","text":"<pre><code>program_version(*args) -&gt; str\n</code></pre> <p>Get the program version.</p> Source code in <code>src/qcop/adapters/geometric.py</code> <pre><code>def program_version(self, *args) -&gt; str:\n    \"\"\"Get the program version.\"\"\"\n    return self.geometric.__version__\n</code></pre>"},{"location":"programs/geometric/#qcop.adapters.geometric.GeometricAdapter.compute_data","title":"compute_data","text":"<pre><code>compute_data(input_data: CompositeCalcSpec, update_func: Callable | None = None, update_interval: float | None = None, propagate_wfn: bool = True, **kwargs) -&gt; tuple[OptimizationData, str]\n</code></pre> <p>Compute the requested calculation.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>CompositeCalcSpec</code> <p>The qcio CompositeCalcSpec object for a computation.</p> required <code>propagate_wfn</code> <code>bool</code> <p>Whether to propagate the wavefunction between steps of the optimization.</p> <code>True</code> Source code in <code>src/qcop/adapters/geometric.py</code> <pre><code>def compute_data(\n    self,\n    input_data: CompositeCalcSpec,\n    update_func: Callable | None = None,\n    update_interval: float | None = None,\n    propagate_wfn: bool = True,\n    **kwargs,\n) -&gt; tuple[OptimizationData, str]:\n    \"\"\"Compute the requested calculation.\n\n    Args:\n        input_data: The qcio CompositeCalcSpec object for a computation.\n        propagate_wfn: Whether to propagate the wavefunction between steps of the\n            optimization.\n    \"\"\"\n    # Update the input object based on its calctype\n    self._update_input_data(input_data)\n    geometric_molecule = self._create_geometric_molecule(input_data.structure)\n    internal_coords_sys = self._setup_coords(input_data, geometric_molecule)\n\n    qcio_adapter = get_adapter(\n        input_data.subprogram, input_data, qcng_fallback=True\n    )\n    optimizer = self._construct_optimizer(\n        input_data,\n        geometric_molecule,\n        internal_coords_sys,\n        qcio_adapter,\n        propagate_wfn=propagate_wfn,\n        update_func=update_func,\n        update_interval=update_interval,\n        **kwargs,\n    )\n\n    # Haven't update DualOutputHandler to send logs using arbitrary update funcs.\n    with capture_logs(\"geometric\", update_func, update_interval) as (_, log_string):\n        try:\n            optimizer.optimizeGeometry()\n        except self.geometric.errors.Error as e:\n            raise ExternalProgramError(\n                program=self.program,\n                message=\"geomeTRIC optimization failed. See the traceback above for details.\",\n            ) from e\n\n    return (\n        OptimizationData(\n            trajectory=optimizer.engine.qcio_trajectory,\n        ),\n        log_string.getvalue(),\n    )\n</code></pre>"},{"location":"programs/overview/","title":"Overview","text":"<p><code>qcop</code> enables standardized operation of dozens of Quantum Chemistry programs including <code>TeraChem</code>, <code>Psi4</code>, <code>rdkit</code>, <code>ORCA</code>, <code>MolPro</code>, <code>geomeTRIC</code>, <code>CREST</code>, <code>xtb</code>, <code>CFOUR</code>, <code>QCore</code>, <code>GAMESS</code>, <code>MRChem</code>, <code>NWChem</code>, <code>Q-Chem</code>, <code>Turbomole</code>, <code>MOPAC</code> and more using qcio standardized data structures and a common pattern for running programs. <code>qcop</code> uses <code>Adapters</code> to operate QC programs in a standardized way. Program <code>Adapters</code> are listed to the left.</p> <p><code>qcop</code> does not standardize keywords across programs, so for detailed instructions on program options and keywords please consult the documentation for each individual program. <code>qcop</code> will pass these options/keywords through to the respective program.</p> <p>This section contains details about how <code>qcop's</code> adapters for each program work and any details that might influence how you use a given program. Supported programs not listed on the left are supported via <code>QCEngine</code> which provides an adapter for numerous additional programs.</p> <p>Special keywords that control the program for a particular program will be listed in the <code>compute_results()</code> method for each adapter.</p>"},{"location":"programs/qcengine/","title":"QCEngine","text":"<p>The QCEngine Adapter enables calculations using all QCEngine supported programs. This engine is used as a fallback for when <code>qcop</code> does not have an <code>Adapter</code> of its own for a given program. Using QCEngine as a fallback can be deactivated by passing <code>qcng_fallback=False</code> to <code>qcop.compute()</code>.</p>"},{"location":"programs/qcengine/#qcop.adapters.qcengine.QCEngineAdapter","title":"qcop.adapters.qcengine.QCEngineAdapter","text":"<pre><code>QCEngineAdapter(external_program: str)\n</code></pre> <p>Adapter for all programs supported by QCEngine.</p> Source code in <code>src/qcop/adapters/qcengine.py</code> <pre><code>def __init__(self, external_program: str) -&gt; None:\n    super().__init__()\n    self.external_program = external_program\n</code></pre>"},{"location":"programs/qcengine/#qcop.adapters.qcengine.QCEngineAdapter.supported_calctypes","title":"supported_calctypes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>supported_calctypes = [energy, gradient, hessian]\n</code></pre> <p>Supported calculation types.</p>"},{"location":"programs/qcengine/#qcop.adapters.qcengine.QCEngineAdapter.program_version","title":"program_version","text":"<pre><code>program_version(*args) -&gt; str\n</code></pre> <p>Get the program version.</p> Source code in <code>src/qcop/adapters/qcengine.py</code> <pre><code>def program_version(self, *args) -&gt; str:\n    \"\"\"Get the program version.\"\"\"\n    from qcengine import get_program\n    from qcengine.exceptions import QCEngineException\n\n    try:\n        adapter = get_program(self.external_program)\n        return adapter.get_version()\n    except QCEngineException as e:\n        raise ExternalProgramError(\n            program=self.program,\n            message=f\"QCEngine could not get version for program {self.external_program}.\",\n        ) from e\n</code></pre>"},{"location":"programs/terachem/","title":"TeraChem","text":""},{"location":"programs/terachem/#qcop.adapters.terachem.TeraChemAdapter","title":"qcop.adapters.terachem.TeraChemAdapter","text":"<p>Adapter for TeraChem.</p>"},{"location":"programs/terachem/#qcop.adapters.terachem.TeraChemAdapter.supported_calctypes","title":"supported_calctypes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>supported_calctypes = [energy, gradient, hessian, optimization]\n</code></pre> <p>Supported calculation types.</p>"},{"location":"programs/terachem/#qcop.adapters.terachem.TeraChemAdapter.program_version","title":"program_version","text":"<pre><code>program_version(stdout: str | None = None) -&gt; str\n</code></pre> <p>Get the program version.</p> <p>Parameters:</p> Name Type Description Default <code>stdout</code> <code>str | None</code> <p>The stdout from the program.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The program version.</p> Source code in <code>src/qcop/adapters/terachem.py</code> <pre><code>def program_version(self, stdout: str | None = None) -&gt; str:\n    \"\"\"Get the program version.\n\n    Args:\n        stdout: The stdout from the program.\n\n    Returns:\n        The program version.\n    \"\"\"\n    if stdout:\n        try:\n            return parse_version(stdout)\n        except qccodec_exceptions.ParserError:\n            # If the version string is not found. Happens when libcuda.so is not\n            # found and TeraChem fails to start. terachem --version will fail too.\n            return \"Could not parse version\"\n    else:\n        try:\n            return execute_subprocess(self.program, [\"--version\"])[17:]\n        except ExternalProgramError:\n            return \"Could not determine version\"\n</code></pre>"},{"location":"programs/terachem/#qcop.adapters.terachem.TeraChemAdapter.compute_data","title":"compute_data","text":"<pre><code>compute_data(input_data: CalcSpec, update_func: Callable | None = None, update_interval: float | None = None, **kwargs) -&gt; tuple[SinglePointData, str]\n</code></pre> <p>Execute TeraChem on the given input.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>CalcSpec</code> <p>The qcio CalcSpec object for a computation.</p> required <code>update_func</code> <code>Callable | None</code> <p>A callback function to call as the program executes.</p> <code>None</code> <code>update_interval</code> <code>float | None</code> <p>The minimum time in seconds between calls to the update_func.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[SinglePointData, str]</code> <p>A tuple of SinglePointData and the stdout str.</p> Source code in <code>src/qcop/adapters/terachem.py</code> <pre><code>def compute_data(\n    self,\n    input_data: CalcSpec,\n    update_func: Callable | None = None,\n    update_interval: float | None = None,\n    **kwargs,\n) -&gt; tuple[SinglePointData, str]:\n    \"\"\"Execute TeraChem on the given input.\n\n    Args:\n        input_data: The qcio CalcSpec object for a computation.\n        update_func: A callback function to call as the program executes.\n        update_interval: The minimum time in seconds between calls to the\n            update_func.\n\n    Returns:\n        A tuple of SinglePointData and the stdout str.\n    \"\"\"\n    # Construct TeraChem native input files\n    try:\n        native_input = qccodec.encode(input_data, self.program)\n    except qccodec.exceptions.EncoderError as e:\n        raise AdapterInputError(program=self.program) from e\n\n    # Write the input files to disk\n    input_filename = \"tc.in\"\n    Path(input_filename).write_text(native_input.input_file)\n    Path(native_input.geometry_filename).write_text(native_input.geometry_file)\n\n    # Execute TeraChem\n    stdout = execute_subprocess(\n        self.program, [input_filename], update_func, update_interval\n    )\n\n    # Get the scratch output directory\n    parent = Path.cwd()\n    # TeraChem creates a directory named scr.&lt;xyz_filename&gt; in the current working\n    scr_dir = next(parent.glob(\"scr.*\"), None)\n    if scr_dir is None:\n        raise ExternalProgramError(\n            self.program, f\"TeraChem did not create a 'scr.' directory in {parent}.\"\n        )\n\n    # Parse output\n    try:\n        results = qccodec.decode(\n            self.program,\n            input_data.calctype,\n            stdout=stdout,\n            directory=scr_dir,\n            input_data=input_data,\n        )\n    except qccodec_exceptions.ParserError as e:\n        raise ExternalProgramError(\n            program=\"qccodec\",\n            message=\"Failed to parse TeraChem output.\",\n            logs=stdout,\n            original_exception=e,\n        ) from e\n    return results, stdout\n</code></pre>"},{"location":"programs/terachem/#qcop.adapters.terachem.TeraChemAdapter.collect_wfn","title":"collect_wfn","text":"<pre><code>collect_wfn() -&gt; dict[str, str | bytes]\n</code></pre> <p>Append wavefunction data to the output.</p> Source code in <code>src/qcop/adapters/terachem.py</code> <pre><code>def collect_wfn(self) -&gt; dict[str, str | bytes]:\n    \"\"\"Append wavefunction data to the output.\"\"\"\n\n    # Naming conventions from TeraChem uses xyz filename as scratch dir postfix\n    scr_postfix = XYZ_FILENAME.split(\".\")[0]\n\n    # Wavefunction filenames\n    wfn_filenames = (\"c0\", \"ca0\", \"cb0\")\n    wfn_paths = [Path(f\"scr.{scr_postfix}/{fn}\") for fn in wfn_filenames]\n    if not any(wfn_path.exists() for wfn_path in wfn_paths):\n        raise AdapterError(f\"No wavefunction files found in {Path.cwd()}\")\n\n    wfns: dict[str, str | bytes] = {}\n    for wfn_path in wfn_paths:\n        if wfn_path.exists():\n            wfns[str(wfn_path)] = wfn_path.read_bytes()\n    return wfns\n</code></pre>"},{"location":"programs/terachem/#qcop.adapters.terachem.TeraChemAdapter.propagate_wfn","title":"propagate_wfn","text":"<pre><code>propagate_wfn(output: Results, calcspec: CalcSpec) -&gt; None\n</code></pre> <p>Propagate the wavefunction from the previous calculation.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>Results</code> <p>The output from a previous calculation containing wavefunction data.</p> required <code>calcspec</code> <code>CalcSpec</code> <p>The CalcSpec object on which to place the wavefunction data.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None. Modifies the calcspec object in place.</p> Source code in <code>src/qcop/adapters/terachem.py</code> <pre><code>def propagate_wfn(self, output: Results, calcspec: CalcSpec) -&gt; None:\n    \"\"\"Propagate the wavefunction from the previous calculation.\n\n    Args:\n        output: The output from a previous calculation containing wavefunction data.\n        calcspec: The CalcSpec object on which to place the wavefunction data.\n\n    Returns:\n        None. Modifies the calcspec object in place.\n    \"\"\"\n\n    # Naming conventions from TeraChem uses xyz filename as scratch dir postfix\n    scr_postfix = XYZ_FILENAME.split(\".\")[0]\n\n    # Wavefunction filenames\n    c0, ca0, cb0 = \"c0\", \"ca0\", \"cb0\"\n\n    files = output.data.files\n    c0_bytes = files.get(f\"scr.{scr_postfix}/{c0}\")\n    ca0_bytes = files.get(f\"scr.{scr_postfix}/{ca0}\")\n    cb0_bytes = files.get(f\"scr.{scr_postfix}/{cb0}\")\n\n    if not c0_bytes and not (ca0_bytes and cb0_bytes):\n        raise AdapterInputError(\n            program=self.program,\n            message=\"Could not find c0 or ca/b0 files in output.\",\n        )\n\n    # Load wavefunction data onto CalcSpec object\n\n    if c0_bytes:\n        calcspec.files[c0] = c0_bytes\n        calcspec.keywords[\"guess\"] = c0\n\n    else:  # ca0_bytes and cb0_bytes\n        assert ca0_bytes and cb0_bytes  # for mypy\n        calcspec.files[ca0] = ca0_bytes\n        calcspec.files[cb0] = cb0_bytes\n        calcspec.keywords[\"guess\"] = f\"{ca0} {cb0}\"\n</code></pre>"},{"location":"programs/terachem/#qcop.adapters.terachem_fe.TeraChemFEAdapter","title":"qcop.adapters.terachem_fe.TeraChemFEAdapter","text":"<pre><code>TeraChemFEAdapter()\n</code></pre> <p>Adapter for TeraChem's Protocol Buffer Server and Frontend file server.</p> Source code in <code>src/qcop/adapters/terachem_fe.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    # Check that xtb-python is installed.\n    self.tcpb = self._ensure_tcpb()\n    self.client = self.tcpb.TCFrontEndClient\n</code></pre>"},{"location":"programs/terachem/#qcop.adapters.terachem_fe.TeraChemFEAdapter.supported_calctypes","title":"supported_calctypes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>supported_calctypes = [energy, gradient]\n</code></pre> <p>Supported calculation types.</p>"},{"location":"programs/terachem/#qcop.adapters.terachem_fe.TeraChemFEAdapter.program_version","title":"program_version","text":"<pre><code>program_version(stdout: str | None = None) -&gt; str\n</code></pre> <p>Program version is not available via the PB server.</p> Source code in <code>src/qcop/adapters/terachem_fe.py</code> <pre><code>def program_version(self, stdout: str | None = None) -&gt; str:\n    \"\"\"Program version is not available via the PB server.\"\"\"\n    return \"\"\n</code></pre>"},{"location":"programs/terachem/#qcop.adapters.terachem_fe.TeraChemFEAdapter.compute_data","title":"compute_data","text":"<pre><code>compute_data(input_data: CalcSpec, update_func: Callable | None = None, update_interval: float | None = None, **kwargs) -&gt; tuple[SinglePointData, str]\n</code></pre> <p>Execute TeraChem on the given input.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>CalcSpec</code> <p>The qcio CalcSpec object for a computation.</p> required <code>update_func</code> <code>Callable | None</code> <p>A callback function to call as the program executes.</p> <code>None</code> <code>update_interval</code> <code>float | None</code> <p>The minimum time in seconds between calls to the update_func.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[SinglePointData, str]</code> <p>A tuple of SinglePointData and the stdout str.</p> Source code in <code>src/qcop/adapters/terachem_fe.py</code> <pre><code>def compute_data(\n    self,\n    input_data: CalcSpec,\n    update_func: Callable | None = None,\n    update_interval: float | None = None,\n    **kwargs,\n) -&gt; tuple[SinglePointData, str]:\n    \"\"\"Execute TeraChem on the given input.\n\n    Args:\n        input_data: The qcio CalcSpec object for a computation.\n        update_func: A callback function to call as the program executes.\n        update_interval: The minimum time in seconds between calls to the\n            update_func.\n\n    Returns:\n        A tuple of SinglePointData and the stdout str.\n    \"\"\"\n    try:\n        with self.client() as client:\n            prog_output = client.compute(input_data)\n    except self.tcpb.exceptions.TCPBError as e:\n        exc = ExternalProgramError(\n            program=self.program,\n            # Pass logs to .compute() via the exception\n            # Will only exist for TeraChemFrontendAdapter\n            logs=e.results.logs,\n        )\n\n        raise exc\n\n    else:\n        # Write files to disk to be collected by BaseAdapter.compute()\n        # Used only for TeraChemFrontendAdapter\n        prog_output.data.save_files()\n\n    return prog_output.data, prog_output.logs\n</code></pre>"},{"location":"programs/terachem/#qcop.adapters.terachem_pbs.TeraChemPBSAdapter","title":"qcop.adapters.terachem_pbs.TeraChemPBSAdapter","text":"<pre><code>TeraChemPBSAdapter()\n</code></pre> <p>Adapter for TeraChem's Protocol Buffer Server.</p> Source code in <code>src/qcop/adapters/terachem_pbs.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    # Check that tcpb is installed.\n    self.tcpb = self._ensure_tcpb()\n    self.client = self.tcpb.TCProtobufClient\n</code></pre>"},{"location":"programs/xtb/","title":"xtb","text":""},{"location":"programs/xtb/#qcop.adapters.xtb.XTBAdapter","title":"qcop.adapters.xtb.XTBAdapter","text":"<pre><code>XTBAdapter()\n</code></pre> <p>Adapter for xtb-python.</p> Source code in <code>src/qcop/adapters/xtb.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    # Check that xtb-python is installed.\n    self.xtb = self._ensure_xtb()\n</code></pre>"},{"location":"programs/xtb/#qcop.adapters.xtb.XTBAdapter.supported_calctypes","title":"supported_calctypes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>supported_calctypes = [energy, gradient]\n</code></pre> <p>Supported calculation types.</p>"},{"location":"programs/xtb/#qcop.adapters.xtb.XTBAdapter.validate_input","title":"validate_input","text":"<pre><code>validate_input(input_data: CalcSpec) -&gt; None\n</code></pre> <p>Validate the input for xtb-python.</p> Source code in <code>src/qcop/adapters/xtb.py</code> <pre><code>def validate_input(self, input_data: CalcSpec) -&gt; None:\n    \"\"\"Validate the input for xtb-python.\"\"\"\n    super().validate_input(input_data)\n    # Check that xtb supports the method.\n    supported_methods = self.xtb.interface.Param.__members__.keys()\n    if input_data.model.method not in supported_methods:\n        raise AdapterInputError(\n            program=self.program,\n            message=f\"Unsupported method '{input_data.model.method}'. \"\n            f\"Supported methods include: {supported_methods}\",\n        )\n</code></pre>"},{"location":"programs/xtb/#qcop.adapters.xtb.XTBAdapter.program_version","title":"program_version","text":"<pre><code>program_version(stdout: str | None = None) -&gt; str\n</code></pre> <p>Get the program version.</p> <p>Parameters:</p> Name Type Description Default <code>stdout</code> <code>str | None</code> <p>The stdout from the program.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The program version.</p> Source code in <code>src/qcop/adapters/xtb.py</code> <pre><code>def program_version(self, stdout: str | None = None) -&gt; str:\n    \"\"\"Get the program version.\n\n    Args:\n        stdout: The stdout from the program.\n\n    Returns:\n        The program version.\n    \"\"\"\n    global CACHED_XTB_VERSION\n    if not CACHED_XTB_VERSION:\n        CACHED_XTB_VERSION = importlib.metadata.version(self.program)\n    return CACHED_XTB_VERSION\n</code></pre>"},{"location":"programs/xtb/#qcop.adapters.xtb.XTBAdapter.compute_data","title":"compute_data","text":"<pre><code>compute_data(input_data: CalcSpec, update_func: Callable | None = None, update_interval: float | None = None, **kwargs) -&gt; tuple[SinglePointData, str]\n</code></pre> <p>Execute xtb on the given input.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>CalcSpec</code> <p>The qcio CalcSpec object for a computation.</p> required <code>update_func</code> <code>Callable | None</code> <p>A callback function to call as the program executes.</p> <code>None</code> <code>update_interval</code> <code>float | None</code> <p>The minimum time in seconds between calls to the update_func.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[SinglePointData, str]</code> <p>A tuple of SinglePointComputedProps and the stdout str.</p> Source code in <code>src/qcop/adapters/xtb.py</code> <pre><code>def compute_data(\n    self,\n    input_data: CalcSpec,\n    update_func: Callable | None = None,\n    update_interval: float | None = None,\n    **kwargs,\n) -&gt; tuple[SinglePointData, str]:\n    \"\"\"Execute xtb on the given input.\n\n    Args:\n        input_data: The qcio CalcSpec object for a computation.\n        update_func: A callback function to call as the program executes.\n        update_interval: The minimum time in seconds between calls to the\n            update_func.\n\n    Returns:\n        A tuple of SinglePointComputedProps and the stdout str.\n    \"\"\"\n    try:\n        # Create Calculator\n        calc = self.xtb.interface.Calculator(\n            getattr(self.xtb.interface.Param, input_data.model.method),\n            np.array(input_data.structure.atomic_numbers),\n            input_data.structure.geometry,\n            input_data.structure.charge,\n            # From https://github.com/grimme-lab/xtb-python/blob/a32309a43e5a6572b033814eacf396328a2a36ed/xtb/qcschema/harness.py#L126 # noqa: E501\n            input_data.structure.multiplicity - 1,\n        )\n        calc.set_verbosity(self.xtb.libxtb.VERBOSITY_FULL)  # all logs\n\n        # Set Keywords\n        for key, value in input_data.keywords.items():\n            # TODO: Need to handle external_charges and solvent\n            getattr(calc, f\"set_{key}\")(value)\n\n        # Capture logs\n        with capture_sys_stdout() as r_pipe:\n            res = calc.singlepoint()\n            # Not sure what this does but it's in the xtb-python docs\n            calc.release_output()\n            stdout = os.read(r_pipe, 100000).decode()\n\n    except self.xtb.interface.XTBException as e:\n        raise ExternalProgramError(program=\"xtb-python\") from e\n\n    # Collect results\n    # TODO: Collect other results xtb produces\n    results = SinglePointData(\n        energy=res.get_energy(),\n        gradient=res.get_gradient(),\n        scf_dipole_moment=res.get_dipole(),\n        wavefunction=Wavefunction(\n            scf_eigenvalues_a=res.get_orbital_eigenvalues(),\n        ),\n    )\n\n    return results, stdout\n</code></pre>"},{"location":"programs/xtb/#example","title":"Example","text":"<pre><code>\"\"\"Must run script like this: python -m examples.xtb\"\"\"\n\nfrom qcio import CalcSpec, CalcType, Structure\n\nfrom qcop import compute\n\n# Create the structure\n# Can also open a structure from a file\n# structure = Structure.open(\"path/to/h2o.xyz\")\nstructure = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[  # type: ignore\n        [0.0, 0.0, 0.0],\n        [0.52421003, 1.68733646, 0.48074633],\n        [1.14668581, -0.45032174, -1.35474466],\n    ],\n)\n\n# Define the calcspec\nspec = CalcSpec(\n    structure=structure,\n    calctype=CalcType.energy,\n    model={\"method\": \"GFN2xTB\"},  # type: ignore\n    keywords={\"max_iterations\": 150},\n)\n\n\nresults = compute(\"xtb\", spec)\nprint(results)\n</code></pre>"}]}