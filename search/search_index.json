{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quantum Chemistry Operate","text":"<p>A package for operating Quantum Chemistry programs using qcio standardized data structures. Compatible with <code>TeraChem</code>, <code>psi4</code>, <code>QChem</code>, <code>NWChem</code>, <code>ORCA</code>, <code>Molpro</code>, <code>geomeTRIC</code> and many more.</p> <p> </p> <p><code>qcop</code> works in harmony with a suite of other quantum chemistry tools for fast, structured, and interoperable quantum chemistry.</p>"},{"location":"#the-qc-suite-of-programs","title":"The QC Suite of Programs","text":"<ul> <li>qcio - Elegant and intuitive data structures for quantum chemistry, featuring seamless Jupyter Notebook visualizations.</li> <li>qcparse - A library for efficient parsing of quantum chemistry data into structured <code>qcio</code> objects.</li> <li>qcop - A package for operating quantum chemistry programs using <code>qcio</code> standardized data structures. Compatible with <code>TeraChem</code>, <code>psi4</code>, <code>QChem</code>, <code>NWChem</code>, <code>ORCA</code>, <code>Molpro</code>, <code>geomeTRIC</code>, and many more, featuring seamless Jupyter Notebook visualizations.</li> <li>BigChem - A distributed application for running quantum chemistry calculations at scale across clusters of computers or the cloud. Bring multi-node scaling to your favorite quantum chemistry program, featuring seamless Jupyter Notebook visualizations.</li> <li><code>ChemCloud</code> - A web application and associated Python client for exposing a BigChem cluster securely over the internet, featuring seamless Jupyter Notebook visualizations.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install qcop\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":"<p><code>qcop</code> uses the <code>qcio</code> data structures to drive quantum chemistry programs in a standardized way. This allows for a simple and consistent interface to a wide variety of quantum chemistry programs. See the qcio library for documentation on the input and output data structures.</p> <p>The <code>compute</code> function is the main entry point for the library and is used to run a calculation.</p> <pre><code>from qcio import Structure, ProgramInput\nfrom qcop import compute\nfrom qcop.exceptions import ExternalProgramError\n# Create the Structure\nh2o = Structure.open(\"h2o.xyz\")\n\n# Define the program input\nprog_input = ProgramInput(\n    structure=h2o,\n    calctype=\"energy\",\n    model={\"method\": \"hf\", \"basis\": \"sto-3g\"},\n    keywords={\"purify\": \"no\", \"restricted\": False},\n)\n\n# Run the calculation; will return ProgramOutput or raise an exception\ntry:\n    po = compute(\"terachem\", prog_input, collect_files=True)\nexcept ExternalProgramError as e:\n    # External QQ program failed in some way\n    po = e.program_output\n    po.input_data # Input data used by the QC program\n    po.success # Will be False\n    po.results # Any half-computed results before the failure\n    po.traceback # Stack trace from the calculation\n    po.ptraceback # Shortcut to print out the traceback in human readable format\n    po.stdout # Stdout log from the calculation\n    raise e\nelse:\n    # Calculation succeeded\n    po.input_data # Input data used by the QC program\n    po.success # Will be True\n    po.results # All structured results from the calculation\n    po.stdout # Stdout log from the calculation\n    po.pstdout # Shortcut to print out the stdout in human readable format\n    po.files # Any files returned by the calculation\n    po.provenance # Provenance information about the calculation\n    po.extras # Any extra information not in the schema\n</code></pre> <p>One may also call <code>compute(..., raise_exc=False)</code> to return a <code>ProgramOutput</code> object rather than raising an exception when a calculation fails. This may allow easier handling of failures in some cases.</p> <pre><code>from qcio import Structure, ProgramInput\nfrom qcop import compute\nfrom qcop.exceptions import ExternalProgramError\n# Create the Structure\nh2o = Structure.open(\"h2o.xyz\")\n\n# Define the program input\nprog_input = ProgramInput(\n    structure=h2o,\n    calctype=\"energy\",\n    model={\"method\": \"hf\", \"basis\": \"sto-3g\"},\n    keywords={\"purify\": \"no\", \"restricted\": False},\n)\n\n# Run the calculation; will return a ProgramOutput objects\npo = compute(\"terachem\", prog_input, collect_files=True, raise_exc=False)\nif not po.success:\n    # External QQ program failed in some way\n    po.input_data # Input data used by the QC program\n    po.success # Will be False\n    po.results # Any half-computed results before the failure\n    po.traceback # Stack trace from the calculation\n    po.ptraceback # Shortcut to print out the traceback in human readable format\n    po.stdout # Stdout log from the calculation\n\nelse:\n    # Calculation succeeded\n    po.input_data # Input data used by the QC program\n    po.success # Will be True\n    po.results # All structured results from the calculation\n    po.stdout # Stdout log from the calculation\n    po.pstdout # Shortcut to print out the stdout in human readable format\n    po.files # Any files returned by the calculation\n    po.provenance # Provenance information about the calculation\n    po.extras # Any extra information not in the schema\n</code></pre> <p>Alternatively, the <code>compute_args</code> function can be used to run a calculation with the input data structures passed in as arguments rather than as a single <code>ProgramInput</code> object.</p> <pre><code>from qcio import Structure\nfrom qcop import compute_args\n# Create the Structure\nh2o = Structure.open(\"h2o.xyz\")\n\n# Run the calculation\noutput = compute_args(\n    \"terachem\",\n    h2o,\n    calctype=\"energy\",\n    model={\"method\": \"hf\", \"basis\": \"sto-3g\"},\n    keywords={\"purify\": \"no\", \"restricted\": False},\n    files={...},\n    collect_files=True\n)\n</code></pre> <p>The behavior of <code>compute()</code> and <code>compute_args()</code> can be tuned by passing in keyword arguments like <code>collect_files</code> shown above. Keywords can modify which scratch directory location to use, whether to delete or keep the scratch files after a calculation completes, what files to collect from a calculation, whether to print the program stdout in real time as the program executes, and whether to propagate a wavefunction through a series of calculations. Keywords also include hooks for passing in update functions that can be called as a program executes in real time. See the compute method docstring for more details.</p> <p>See the /examples directory for more examples.</p>"},{"location":"#visualization","title":"\u2728 Visualization \u2728","text":"<p>Visualize all your results with a single line of code!</p> <p>First install the visualization module:</p> <pre><code>pip install qcio[view]\n</code></pre> <p>or if your shell requires <code>''</code> around arguments with brackets:</p> <pre><code>pip install 'qcio[view]'\n</code></pre> <p>Then in a Jupyter notebook import the <code>qcio</code> view module and call <code>view.view(...)</code> passing it one or any number of <code>qcio</code> objects you want to visualizing including <code>Structure</code> objects or any <code>ProgramOutput</code> object. You may also pass an array of <code>titles</code> and/or <code>subtitles</code> to add additional information to the molecular structure display. If no titles are passed <code>qcio</code> with look for <code>Structure</code> identifiers such as a name or SMILES to label the <code>Structure</code>.</p> <p></p> <p>Seamless visualizations for <code>ProgramOutput</code> objects make results analysis easy!</p> <p></p> <p>Single point calculations display their results in a table.</p> <p></p> <p>If you want to use the HTML generated by the viewer to build your own dashboards use the functions inside of <code>qcio.view.py</code> that begin with the word <code>generate_</code> to create HTML you can insert into any dashboard.</p>"},{"location":"#support","title":"Support","text":"<p>If you have any issues with <code>qcop</code> or would like to request a feature, please open an issue.</p>"},{"location":"examples/conformer_search/","title":"Conformer Search","text":"<pre><code>from qcio import ProgramInput, Structure\n\nfrom qcop import compute, exceptions\n\n# Create the structure\n# Can also open a structure from a file\n# structure = Structure.open(\"path/to/h2o.xyz\")\nstructure = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[  # type: ignore\n        [0.0, 0.0, 0.0],\n        [0.52421003, 1.68733646, 0.48074633],\n        [1.14668581, -0.45032174, -1.35474466],\n    ],\n)\n\n# Define the program input\nprog_input = ProgramInput(\n    structure=structure,\n    calctype=\"conformer_search\",  # type: ignore\n    model={\"method\": \"gfnff\"},  # type: ignore\n    keywords={\"calculation\": {\"level\": [{\"alpb\": \"acetonitrile\"}]}},\n)\n\n# Run the calculation\ntry:\n    # prog_output is instance of ProgramOutput\n    prog_output = compute(\n        \"crest\", prog_input, collect_files=True, collect_rotamers=False\n    )\nexcept exceptions.QCOPBaseError as e:\n    prog_output = e.program_output\n    print(prog_output.stdout)  # or output.pstdout for short\n    print(f\"Success: {prog_output.success}\")  # False\n    print(prog_output.input_data)  # Input data used to generate the calculation\n    print(prog_output.provenance)  # Provenance of generated calculation\n    print(prog_output.traceback)  # or output.ptraceback for short\n    raise\n\nelse:\n    # Check results\n    print(prog_output.stdout)  # or output.pstdout for short\n    print(f\"Success: {prog_output.success}\")  # True\n    print(\"output.results: \", prog_output.results)\n    print(\"output.results.conformer_energies:\", prog_output.results.conformer_energies)\n    print(\n        \"output.results.conformer_energies_relative:\",\n        prog_output.results.conformer_energies_relative,\n    )\n    print(prog_output.input_data)  # Input data used to generate the calculation\n    print(prog_output.provenance)  # Provenance of generated calculation\n</code></pre>"},{"location":"examples/file_input/","title":"File Input","text":"<p>The <code>File Input</code> can be used as an escape hatch when you want to perform a calculation type that is not yet supported by <code>qcop</code> or use a program not yet supported by <code>qcop</code>. You can submit the program's native input files to the program and <code>qcop</code> will execute the program, collect all the outputs, and return them to you. These calculations could be an MD run, some unique calculation type not supported by <code>qcop</code>, or any arbitrary command you can send to any command-line executable program.</p> <pre><code>\"\"\"An example of how to create a FileInput object for a QC Program.\"\"\"\n\nfrom pathlib import Path\n\nfrom qcio import FileInput, Structure\n\nfrom qcop import compute\n\n# Input files for QC Program\ninp_file = Path(\"path/to/tc.in\").read_text()  # Or your own function to create tc.in\n\n# Structure object to XYZ file\nstructure = Structure.open(\"path/to/my/mol.xyz\")\nxyz_str = structure.to_xyz()  # type: ignore\n\n# Create a FileInput object for TeraChem\nfile_inp = FileInput(\n    files={\"tc.in\": inp_file, \"coords.xyz\": xyz_str}, cmdline_args=[\"tc.in\"]\n)\n\n# This will write the files to disk in a temporary directory and then run\n# \"terachem tc.in\" in that directory.\noutput = compute(\"terachem\", file_inp, print_stdout=True)\n\n# Data\noutput.stdout\noutput.input_data\noutput.results.files  # Has all the files terachem creates\noutput.results.files.keys()  # Print out file names\n# Saves all outputs with the exact structure produced by the QC program\noutput.results.save_files(\"to/this/directory\")\n</code></pre>"},{"location":"examples/optimization/","title":"Optimization","text":""},{"location":"examples/optimization/#geometric","title":"geomeTRIC","text":"<pre><code>\"\"\"Example of using geometric subprogram to optimize H2 bond length.\n\nConstraints docs: https://geometric.readthedocs.io/en/latest/constraints.html\n\"\"\"\n\nfrom qcio import DualProgramInput, Structure\n\nfrom qcop import compute, exceptions\n\n# Create Structure\nh2 = Structure(\n    symbols=[\"H\", \"H\"],\n    geometry=[[0, 0.0, 0.0], [0, 0, 1.4]],  # type: ignore\n)\n\n# Define the program input\nprog_inp = DualProgramInput(\n    calctype=\"optimization\",  # type: ignore\n    structure=h2,\n    subprogram=\"terachem\",\n    subprogram_args={  # type: ignore\n        \"model\": {\"method\": \"HF\", \"basis\": \"6-31g\"},\n        \"keywords\": {\"purify\": \"no\"},\n    },\n    keywords={\n        \"check\": 3,\n        # This is obviously a stupid constraint, but it's just an example to show how\n        # to use them\n        \"constraints\": {\n            \"freeze\": [\n                {\"type\": \"distance\", \"indices\": [0, 1], \"value\": 1.4},\n            ],\n        },\n    },\n)\n\n# Run calculation\ntry:\n    output = compute(\"geometric\", prog_inp, propagate_wfn=True, rm_scratch_dir=False)\nexcept exceptions.QCOPBaseError as e:\n    # Calculation failed\n    output = e.program_output\n    print(output.stdout)  # or output.pstdout for short\n    # Input data used to generate the calculation\n    print(output.input_data)\n    # Provenance of generated calculation\n    print(output.provenance)\n    print(output.traceback)\n    raise\n\nelse:\n    # Check results\n    print(\"Energies:\", output.results.energies)\n    print(\"Structures:\", output.results.structures)\n    print(\"Trajectory:\", output.results.trajectory)\n    # Stdout from the program\n    print(output.stdout)  # or output.pstdout for short\n    # Input data used to generate the calculation\n    print(output.input_data)\n    # Provenance of generated calculation\n    print(output.provenance)\n</code></pre>"},{"location":"examples/optimization/#terachem","title":"TeraChem","text":"<pre><code>\"\"\"Example of how to run an optimization calculation with TeraChem using qcop.\"\"\"\n\nfrom qcio import ProgramInput, Structure\n\nfrom qcop import compute, exceptions\n\n# Create the structure\n# Can also open a structure from a file\n# structure = Structure.open(\"path/to/h2o.xyz\")\nstructure = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[  # type: ignore\n        [0.0, 0.0, 0.0],\n        [0.52421003, 1.68733646, 0.48074633],\n        [1.14668581, -0.45032174, -1.35474466],\n    ],\n)\n\n# Define the program input\nprog_input = ProgramInput(\n    structure=structure,\n    # Can be \"energy\", \"gradient\", \"hessian\", \"optimization\", \"transition_state\"\n    calctype=\"optimization\",  # type: ignore\n    model={\"method\": \"hf\", \"basis\": \"sto-3g\"},  # type: ignore\n    keywords={\"purify\": \"no\", \"new_minimizer\": \"yes\"},  # new_minimizer yes is required\n)\n\n# Run the calculation\ntry:\n    # prog_output is instance of ProgramOutput\n    prog_output = compute(\"terachem\", prog_input, collect_files=True)\nexcept exceptions.QCOPBaseError as e:\n    prog_output = e.program_output\n    print(prog_output.stdout)  # or output.pstdout for short\n    print(f\"Success: {prog_output.success}\")  # False\n    print(prog_output.input_data)  # Input data used to generate the calculation\n    print(prog_output.provenance)  # Provenance of generated calculation\n    print(prog_output.traceback)  # or output.ptraceback for short\n    raise\n\nelse:\n    # Check results\n    print(prog_output.stdout)  # or output.pstdout for short\n    print(f\"Success: {prog_output.success}\")  # True\n    print(\"output.results: \", prog_output.results)\n    print(\"output.results.energies:\", prog_output.results.energies)\n    print(\"output.results.structures:\", prog_output.results.structures)\n    print(\"output.results.final_structure:\", prog_output.results.final_structure)\n    print(prog_output.input_data)  # Input data used to generate the calculation\n    print(prog_output.provenance)  # Provenance of generated calculation\n</code></pre>"},{"location":"examples/overview/","title":"Overview","text":"<p>Calculations are run by calling the <code>qcop.compute()</code> function with the relevant arguments and keywords like this:</p> <pre><code>from qcio import Structure, ProgramInput\nfrom qcop import compute\n\n# Create the Structure\nstructure = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[  # type: ignore\n        [0.0, 0.0, 0.0],\n        [0.52421003, 1.68733646, 0.48074633],\n        [1.14668581, -0.45032174, -1.35474466],\n    ],\n)\n\n# Define the program input\nprog_input = ProgramInput(\n    structure=h2o,\n    calctype=\"energy\",\n    model={\"method\": \"hf\", \"basis\": \"sto-3g\"},\n    keywords={\"purify\": \"no\", \"restricted\": False},\n)\n\n# Run the calculation; will return ProgramOutput or raise an exception\nprog_output = compute(\"terachem\", prog_input, collect_files=True)\n</code></pre> <p>The <code>compute</code> selects the correct program adapter and then calls <code>adapter.compute()</code>. The available arguments and keywords for the top level <code>compute()</code> function match those shown here:</p> <pre><code>\n</code></pre>"},{"location":"examples/overview/#qcop.adapters.BaseAdapter.compute","title":"qcop.adapters.BaseAdapter.compute","text":"<pre><code>compute(\n    inp_obj: InputType,\n    *,\n    scratch_dir: Optional[StrOrPath] = None,\n    rm_scratch_dir: bool = True,\n    collect_stdout: bool = True,\n    collect_files: bool = False,\n    collect_wfn: bool = False,\n    update_func: Optional[Callable] = None,\n    update_interval: Optional[float] = None,\n    print_stdout: bool = False,\n    raise_exc: bool = True,\n    propagate_wfn: bool = False,\n    **adapter_kwargs\n) -&gt; ProgramOutput[InputType, ResultsType]\n</code></pre> <p>Compute the given input using the adapter's program.</p> <p>Parameters:</p> Name Type Description Default <code>inp_obj</code> <code>InputType</code> <p>A qcio input object for a computation. E.g. A FileInput, ProgramInput or DualProgramInput.</p> required <code>scratch_dir</code> <code>Optional[StrOrPath]</code> <p>The scratch directory for the program. If None, a new directory is created in the system default temporary directory. If rm_scratch_dir is True this directory will be deleted after the program finishes.</p> <code>None</code> <code>rm_scratch_dir</code> <code>bool</code> <p>Delete the scratch directory after the program exits.</p> <code>True</code> <code>collect_stdout</code> <code>bool</code> <p>Whether to collect stdout/stderr from the program as output. Failed computations will always collect stdout/stderr.</p> <code>True</code> <code>collect_files</code> <code>bool</code> <p>Collect all files generated by the QC program as output.</p> <code>False</code> <code>collect_wfn</code> <code>bool</code> <p>Collect the wavefunction file(s) from the calculation. Not every program will support this. Use collect_files to collect all files including the wavefunction.</p> <code>False</code> <code>update_func</code> <code>Optional[Callable]</code> <p>A function to call as the program executes. The function must accept the in-process stdout/stderr output as a string for its first argument.</p> <code>None</code> <code>update_interval</code> <code>Optional[float]</code> <p>The minimum time in seconds between calls to the update_func.</p> <code>None</code> <code>print_stdout</code> <code>bool</code> <p>Whether to print stdout/stderr to the terminal in real time as the program executes. Will be ignored if an update_func passed.</p> <code>False</code> <code>raise_exc</code> <code>bool</code> <p>If False, qcop will return a ProgramOutput object when the QC program fails rather than raise an exception.</p> <code>True</code> <code>propagate_wfn</code> <code>bool</code> <p>For any adapter performing a sequential task, such as a geometry optimization, propagate the wavefunction from the previous step to the next step. This is useful for accelerating convergence by using a previously computed wavefunction as a starting guess. If an adapter does not support wavefunction propagation, an AdapterInputError will be raised.</p> <code>False</code> <code>**adapter_kwargs</code> <p>Additional keyword arguments to pass to the adapter or qcng.compute().</p> <code>{}</code> <p>Returns:</p> Type Description <code>ProgramOutput[InputType, ResultsType]</code> <p>A ProgramOutput object containing the results of the computation.</p> <p>Raises:</p> Type Description <code>AdapterNotFoundError</code> <p>If the program is not supported (i.e., no Adapter is implemented for the program in qcop or qcengine).</p> <code>ProgramNotFoundError</code> <p>If the program executable is not found on the system at execution time. This likely means the program is not installed or not available on the $PATH.</p> <code>AdapterInputError</code> <p>If the input is invalid for the adapter.</p> <code>ExternalProgramExecutionError</code> <p>If the QC program fails during execution.</p> <code>QCEngineError</code> <p>If QCEngine performs the computation raises an error.</p> Source code in <code>qcop/adapters/base.py</code> <pre><code>def compute(\n    self,\n    inp_obj: InputType,\n    *,\n    scratch_dir: Optional[StrOrPath] = None,\n    rm_scratch_dir: bool = True,\n    collect_stdout: bool = True,\n    collect_files: bool = False,\n    collect_wfn: bool = False,\n    update_func: Optional[Callable] = None,\n    update_interval: Optional[float] = None,\n    print_stdout: bool = False,\n    raise_exc: bool = True,\n    propagate_wfn: bool = False,\n    **adapter_kwargs,\n) -&gt; ProgramOutput[InputType, ResultsType]:\n    \"\"\"Compute the given input using the adapter's program.\n\n    Args:\n        inp_obj: A qcio input object for a computation. E.g. A FileInput,\n            ProgramInput or DualProgramInput.\n        scratch_dir: The scratch directory for the program. If None, a new directory\n            is created in the system default temporary directory. If rm_scratch_dir\n            is True this directory will be deleted after the program finishes.\n        rm_scratch_dir: Delete the scratch directory after the program exits.\n        collect_stdout: Whether to collect stdout/stderr from the program as output.\n            Failed computations will always collect stdout/stderr.\n        collect_files: Collect all files generated by the QC program as output.\n        collect_wfn: Collect the wavefunction file(s) from the calculation.\n            Not every program will support this. Use collect_files to collect\n            all files including the wavefunction.\n        update_func: A function to call as the program executes. The function must\n            accept the in-process stdout/stderr output as a string for its first\n            argument.\n        update_interval: The minimum time in seconds between calls to the\n            update_func.\n        print_stdout: Whether to print stdout/stderr to the terminal in real time as\n            the program executes. Will be ignored if an update_func passed.\n        raise_exc: If False, qcop will return a ProgramOutput object when the QC\n            program fails rather than raise an exception.\n        propagate_wfn: For any adapter performing a sequential task, such\n            as a geometry optimization, propagate the wavefunction from the previous\n            step to the next step. This is useful for accelerating convergence by\n            using a previously computed wavefunction as a starting guess. If an\n            adapter does not support wavefunction propagation, an AdapterInputError\n            will be raised.\n        **adapter_kwargs: Additional keyword arguments to pass to the adapter or\n            qcng.compute().\n\n    Returns:\n        A ProgramOutput object containing the results of the computation.\n\n    Raises:\n        AdapterNotFoundError: If the program is not supported (i.e., no Adapter\n            is implemented for the program in qcop or qcengine).\n        ProgramNotFoundError: If the program executable is not found on the\n            system at execution time. This likely means the program is not installed\n            or not available on the $PATH.\n        AdapterInputError: If the input is invalid for the adapter.\n        ExternalProgramExecutionError: If the QC program fails during execution.\n        QCEngineError: If QCEngine performs the computation raises an error.\n    \"\"\"\n    # Print stdout to terminal in real time as program executes\n    if print_stdout and update_func is None:\n        update_func, update_interval = (\n            lambda _, stdout_new: print(stdout_new),\n            0.1,\n        )\n\n    # cd to a temporary directory to run the program.\n    with tmpdir(self.uses_files, scratch_dir, rm_scratch_dir) as final_scratch_dir:\n        if self.uses_files:  # Write non structured input files to disk.\n            inp_obj.save_files()\n\n        # Define outputs\n        output_dict: dict[str, Any] = {}\n        stdout: Optional[str] = None\n        results: Results\n        exc: Optional[QCOPBaseError] = None\n        program_version: Optional[str] = None\n\n        start = time()\n        try:\n            # Validate input object\n            self.validate_input(inp_obj)\n\n            # Execute the program. results will be None if FileInput\n            results, stdout = self.compute_results(\n                inp_obj,\n                update_func,\n                update_interval,\n                propagate_wfn=propagate_wfn,\n                **adapter_kwargs,\n            )\n            # None value covers FileInput case\n            # TODO: Is there a type safe way to handle this??\n            output_dict[\"success\"] = True\n\n            # Optionally collect wavefunction file\n            if collect_wfn and not collect_files:\n                output_dict[\"files\"] = self.collect_wfn()\n\n        except QCOPBaseError as e:\n            # TODO: Is there a type safe way to handle this??\n            exc = e\n            output_dict[\"success\"] = False\n            # Any half-completed results\n            results = getattr(e, \"results\") or Files()\n            stdout = getattr(e, \"stdout\", stdout)\n            # For mypy because e.stdout is not of a known type\n            stdout = str(stdout) if stdout is not None else None\n            output_dict[\"traceback\"] = traceback.format_exc()\n\n        wall_time = time() - start\n\n        try:\n            program_version = self.program_version(stdout)\n        except ProgramNotFoundError:\n            pass  # program_version = None set above\n\n        # Construct Provenance object\n        provenance = construct_provenance(\n            self.program,\n            program_version,\n            final_scratch_dir,\n            wall_time,\n        )\n\n        # Always collect for failures; otherwise obey collect_stdout\n        stdout = stdout if not output_dict[\"success\"] or collect_stdout else None\n\n        # Construct output object\n        output_dict.update(\n            {\n                \"input_data\": inp_obj,\n                \"stdout\": stdout,\n                \"results\": results,\n                \"provenance\": provenance,\n            }\n        )\n        output_obj = ProgramOutput[InputType, ResultsType](**output_dict)\n\n        # Collect files generated by the program\n        if self.uses_files and (collect_files or type(inp_obj) is FileInput):\n            output_obj.results.add_files(\n                final_scratch_dir,\n                recursive=True,\n                exclude=list(inp_obj.files.keys()),\n            )\n\n    # Append ProgramOutput to exception and raise if raise_exc=True\n    # Helpful for BigChem and ChemCloud exception handling\n    if raise_exc and exc:\n        exc.program_output = output_obj\n        raise exc\n\n    return output_obj\n</code></pre>"},{"location":"examples/single_point/","title":"Single Point","text":"<pre><code>from qcio import ProgramInput, Structure\n\nfrom qcop import compute, exceptions\n\n# Create the structure\n# Can also open a structure from a file\n# structure = Structure.open(\"path/to/h2o.xyz\")\nstructure = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[  # type: ignore\n        [0.0, 0.0, 0.0],\n        [0.52421003, 1.68733646, 0.48074633],\n        [1.14668581, -0.45032174, -1.35474466],\n    ],\n)\n\n# Define the program input\nprog_input = ProgramInput(\n    structure=structure,\n    # Can be \"energy\", \"gradient\", \"hessian\"\n    calctype=\"energy\",  # type: ignore\n    model={\"method\": \"hf\", \"basis\": \"sto-3g\"},  # type: ignore\n    keywords={\"purify\": \"no\"},\n)\n\n# Run the calculation\ntry:\n    # prog_output is instance of ProgramOutput\n    prog_output = compute(\"terachem\", prog_input, collect_files=True)\nexcept exceptions.QCOPBaseError as e:\n    prog_output = e.program_output\n    print(prog_output.stdout)  # or output.pstdout for short\n    print(f\"Success: {prog_output.success}\")  # False\n    print(prog_output.input_data)  # Input data used to generate the calculation\n    print(prog_output.provenance)  # Provenance of generated calculation\n    print(prog_output.traceback)  # or output.ptraceback for short\n    raise\n\nelse:\n    # Check results\n    print(prog_output.stdout)  # or output.pstdout for short\n    print(f\"Success: {prog_output.success}\")  # True\n    print(\"output.results: \", prog_output.results)\n    print(\"output.results.energy:\", prog_output.results.energy)\n    print(\"output.results.gradient:\", prog_output.results.gradient)\n    print(\"output.results.hessian:\", prog_output.results.hessian)\n    print(prog_output.input_data)  # Input data used to generate the calculation\n    print(prog_output.provenance)  # Provenance of generated calculation\n</code></pre>"},{"location":"programs/crest/","title":"CREST","text":"<p>Danger</p> <p>Solvation using CREST's new default runtime, <code>tblite</code>, is current buggy. For details see this issue. According to this comment only <code>gfnff</code> and <code>gfn0</code> work correctly with either <code>alpb</code> or <code>gbsa</code> solvent option. If you want to use solvation you need to use the <code>--legacy</code> mode which uses <code>xtb</code> instead of <code>tblite</code> for the calculation backend. Some progress is being made on this issue in this PR.</p>"},{"location":"programs/crest/#qcop.adapters.crest.CRESTAdapter","title":"qcop.adapters.crest.CRESTAdapter","text":"<p>Adapter for CREST.</p> Note <p>The <code>ProgramInput.keywords</code> attribute is used to create the input file for CREST. This means that the structure of the <code>keywords</code> attribute should match that of CREST's input specification. Keywords such as method, charge, and uhf (which are stored on the <code>Model</code> and <code>Structure</code>; uhf is <code>multiplicity - 1</code>) will be added to the input file automatically.</p> Warning <p>CREST does not exit with a non-zero exit code on failure. Instead, it prints \"FAILED\" in the stdout. This adapter will raise an ExternalProgramError if \"FAILED\" is found in the stdout.</p> Warning <p>CREST automatically translates the input geometry to the origin. This means that the input geometry printed to CREST's stdout will not match the input structure; however, all computed values (such as energies, gradients, etc.) are still valid because they are translationally invariant.</p>"},{"location":"programs/crest/#qcop.adapters.crest.CRESTAdapter.supported_calctypes","title":"supported_calctypes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>supported_calctypes = [\n    energy,\n    gradient,\n    hessian,\n    optimization,\n    conformer_search,\n]\n</code></pre> <p>Supported calculation types.</p>"},{"location":"programs/crest/#qcop.adapters.crest.CRESTAdapter.program_version","title":"program_version","text":"<pre><code>program_version(stdout: Optional[str] = None) -&gt; str\n</code></pre> <p>Get the program version.</p> <p>Parameters:</p> Name Type Description Default <code>stdout</code> <code>Optional[str]</code> <p>The stdout from the program.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The program version.</p> Source code in <code>qcop/adapters/crest.py</code> <pre><code>def program_version(self, stdout: Optional[str] = None) -&gt; str:\n    \"\"\"Get the program version.\n\n    Args:\n        stdout: The stdout from the program.\n\n    Returns:\n        The program version.\n    \"\"\"\n    if not stdout:\n        stdout = execute_subprocess(self.program, [\"--version\"])\n    return crest.parse_version_string(stdout)\n</code></pre>"},{"location":"programs/crest/#qcop.adapters.crest.CRESTAdapter.compute_results","title":"compute_results","text":"<pre><code>compute_results(\n    inp_obj: ProgramInput,\n    update_func: Optional[Callable] = None,\n    update_interval: Optional[float] = None,\n    collect_rotamers: bool = False,\n    **kwargs\n) -&gt; tuple[\n    Union[\n        SinglePointResults,\n        OptimizationResults,\n        ConformerSearchResults,\n    ],\n    str,\n]\n</code></pre> <p>Execute CREST on the given input.</p> <p>Parameters:</p> Name Type Description Default <code>inp_obj</code> <code>ProgramInput</code> <p>The qcio ProgramInput object for a computation.</p> required <code>update_func</code> <code>Optional[Callable]</code> <p>A function to call with the stdout at regular intervals.</p> <code>None</code> <code>update_interval</code> <code>Optional[float]</code> <p>The interval at which to call the update function.</p> <code>None</code> <code>collect_rotamers</code> <code>bool</code> <p>Collect rotamers if doing a conformer_search. Defaults to False since rotamers are usually not of interest and there will be many.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[Union[SinglePointResults, OptimizationResults, ConformerSearchResults], str]</code> <p>A tuple of ConformerSearchResults and the stdout str.</p> Source code in <code>qcop/adapters/crest.py</code> <pre><code>def compute_results(\n    self,\n    inp_obj: ProgramInput,\n    update_func: Optional[Callable] = None,\n    update_interval: Optional[float] = None,\n    collect_rotamers: bool = False,\n    **kwargs,\n) -&gt; tuple[\n    Union[SinglePointResults, OptimizationResults, ConformerSearchResults], str\n]:\n    \"\"\"Execute CREST on the given input.\n\n    Args:\n        inp_obj: The qcio ProgramInput object for a computation.\n        update_func: A function to call with the stdout at regular intervals.\n        update_interval: The interval at which to call the update function.\n        collect_rotamers: Collect rotamers if doing a conformer_search. Defaults to\n            False since rotamers are usually not of interest and there will be many.\n\n    Returns:\n        A tuple of ConformerSearchResults and the stdout str.\n    \"\"\"\n    # Create CREST native input files\n    try:\n        native_inp = qcparse.encode(inp_obj, self.program)\n    except qcparse.exceptions.EncoderError as e:\n        raise AdapterInputError(program=self.program) from e\n\n    # Write the input files to disk\n    inp_file, struct_file = Path(\"input.toml\"), Path(native_inp.geometry_filename)\n    inp_file.write_text(native_inp.input_file)\n    struct_file.write_text(native_inp.geometry_file)\n\n    # Execute CREST\n    stdout = execute_subprocess(\n        self.program, [inp_file.name], update_func, update_interval\n    )\n\n    # Parse the output\n    try:\n        if inp_obj.calctype == CalcType.conformer_search:\n            results = crest.parse_conformer_search_dir(\n                \".\",\n                charge=inp_obj.structure.charge,\n                multiplicity=inp_obj.structure.multiplicity,\n                collect_rotamers=collect_rotamers,\n            )\n            # Add identifiers to the conformers and rotamers if topo is unchanged\n            if inp_obj.keywords.get(\"topo\", True):\n                ids = inp_obj.structure.identifiers.model_dump()\n                for struct_type in [\"conformers\", \"rotamers\"]:\n                    for struct in getattr(results, struct_type):\n                        struct.add_identifiers(**ids)\n\n        elif inp_obj.calctype in {CalcType.energy, CalcType.gradient}:\n            results = crest.parse_singlepoint_dir(\".\")\n\n        elif inp_obj.calctype == CalcType.optimization:\n            results = crest.parse_optimization_dir(\n                \".\", inp_obj=inp_obj, stdout=stdout\n            )\n\n        elif inp_obj.calctype == CalcType.hessian:\n            results = crest.parse_numhess_dir(\".\", stdout=stdout)\n    except qcparse.exceptions.ParserError as e:\n        raise ExternalProgramError(\n            program=\"qcparse\",\n            message=\"Failed to parse CREST output.\",\n            stdout=stdout,\n            original_exception=e,\n        ) from e\n\n    # CREST does not exit with a non-zero exit code on failure\n    if \"FAILED\" in stdout:\n        raise ExternalProgramError(\n            program=self.program,\n            message=f\"CREST calculation failed. See the stdout for more information.\",\n            results=results,\n            stdout=stdout,\n        )\n    return results, stdout\n</code></pre>"},{"location":"programs/geometric/","title":"geomeTRIC","text":""},{"location":"programs/geometric/#qcop.adapters.geometric.GeometricAdapter","title":"qcop.adapters.geometric.GeometricAdapter","text":"<pre><code>GeometricAdapter()\n</code></pre> <p>Adapter for geomeTRIC.</p> Source code in <code>qcop/adapters/geometric.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    # Check that geomeTRIC is installed\n    self.geometric = self._ensure_geometric_installed()\n    # Dictionary from geometric.run_json; copying QCSchema workflow\n    self.coordsys_params = {\n        \"cart\": (self.geometric.internal.CartesianCoordinates, False, False),\n        \"prim\": (self.geometric.internal.PrimitiveInternalCoordinates, True, False),\n        \"dlc\": (\n            self.geometric.internal.DelocalizedInternalCoordinates,\n            True,\n            False,\n        ),\n        \"hdlc\": (\n            self.geometric.internal.DelocalizedInternalCoordinates,\n            False,\n            True,\n        ),\n        \"tric\": (\n            self.geometric.internal.DelocalizedInternalCoordinates,\n            False,\n            False,\n        ),\n    }\n</code></pre>"},{"location":"programs/geometric/#qcop.adapters.geometric.GeometricAdapter.supported_calctypes","title":"supported_calctypes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>supported_calctypes = [optimization, transition_state]\n</code></pre> <p>Supported calculation types.</p>"},{"location":"programs/geometric/#qcop.adapters.geometric.GeometricAdapter.program_version","title":"program_version","text":"<pre><code>program_version(*args) -&gt; str\n</code></pre> <p>Get the program version.</p> Source code in <code>qcop/adapters/geometric.py</code> <pre><code>def program_version(self, *args) -&gt; str:\n    \"\"\"Get the program version.\"\"\"\n    return self.geometric.__version__\n</code></pre>"},{"location":"programs/geometric/#qcop.adapters.geometric.GeometricAdapter.compute_results","title":"compute_results","text":"<pre><code>compute_results(\n    inp_obj: DualProgramInput,\n    update_func: Optional[Callable] = None,\n    update_interval: Optional[float] = None,\n    propagate_wfn: bool = True,\n    **kwargs\n) -&gt; tuple[OptimizationResults, str]\n</code></pre> <p>Compute the requested calculation.</p> <p>Parameters:</p> Name Type Description Default <code>inp_obj</code> <code>DualProgramInput</code> <p>The qcio DualProgramInput object for a computation.</p> required <code>propagate_wfn</code> <code>bool</code> <p>Whether to propagate the wavefunction between steps of the optimization.</p> <code>True</code> Source code in <code>qcop/adapters/geometric.py</code> <pre><code>def compute_results(\n    self,\n    inp_obj: DualProgramInput,\n    update_func: Optional[Callable] = None,\n    update_interval: Optional[float] = None,\n    propagate_wfn: bool = True,\n    **kwargs,\n) -&gt; tuple[OptimizationResults, str]:\n    \"\"\"Compute the requested calculation.\n\n    Args:\n        inp_obj: The qcio DualProgramInput object for a computation.\n        propagate_wfn: Whether to propagate the wavefunction between steps of the\n            optimization.\n    \"\"\"\n    # Update the input object based on its calctype\n    self._update_inp_obj(inp_obj)\n    geometric_molecule = self._create_geometric_molecule(inp_obj.structure)\n    internal_coords_sys = self._setup_coords(inp_obj, geometric_molecule)\n\n    qcio_adapter = get_adapter(inp_obj.subprogram, inp_obj, qcng_fallback=True)\n    optimizer = self._construct_optimizer(\n        inp_obj,\n        geometric_molecule,\n        internal_coords_sys,\n        qcio_adapter,\n        propagate_wfn=propagate_wfn,\n        update_func=update_func,\n        update_interval=update_interval,\n        **kwargs,\n    )\n\n    # Haven't update DualOutputHandler to send logs using arbitrary update funcs.\n    with capture_logs(\"geometric\", update_func, update_interval) as (_, log_string):\n        try:\n            optimizer.optimizeGeometry()\n        except self.geometric.errors.Error as e:\n            raise ExternalProgramError(\n                program=self.program,\n                message=\"geomeTRIC optimization failed. See the traceback above for details.\",\n            ) from e\n\n    return (\n        OptimizationResults(\n            trajectory=optimizer.engine.qcio_trajectory,\n        ),\n        log_string.getvalue(),\n    )\n</code></pre>"},{"location":"programs/overview/","title":"Overview","text":"<p><code>qcop</code> enables standardized operation of dozens of Quantum Chemistry programs including <code>TeraChem</code>, <code>Psi4</code>, <code>rdkit</code>, <code>ORCA</code>, <code>MolPro</code>, <code>geomeTRIC</code>, <code>CREST</code>, <code>xtb</code>, <code>CFOUR</code>, <code>QCore</code>, <code>GAMESS</code>, <code>MRChem</code>, <code>NWChem</code>, <code>Q-Chem</code>, <code>Turbomole</code>, <code>MOPAC</code> and more using qcio standardized data structures and a common pattern for running programs. <code>qcop</code> uses <code>Adapters</code> to operate QC programs in a standardized way. Program <code>Adapters</code> are listed to the left.</p> <p><code>qcop</code> does not standardize keywords across programs, so for detailed instructions on program options and keywords please consult the documentation for each individual program. <code>qcop</code> will pass these options/keywords through to the respective program.</p> <p>This section contains details about how <code>qcop's</code> adapters for each program work and any details that might influence how you use a given program. Supported programs not listed on the left are supported via <code>QCEngine</code> which provides an adapter for numerous additional programs.</p> <p>Special keywords that control the program for a particular program will be listed in the <code>compute_results()</code> method for each adapter.</p>"},{"location":"programs/qcengine/","title":"QCEngine","text":"<p>The QCEngine Adapter enables calculations using all QCEngine supported programs. This engine is used as a fallback for when <code>qcop</code> does not have an <code>Adapter</code> of its own for a given program. Using QCEngine as a fallback can be deactivated by passing <code>qcng_fallback=False</code> to <code>qcop.compute()</code>.</p>"},{"location":"programs/qcengine/#qcop.adapters.qcengine.QCEngineAdapter","title":"qcop.adapters.qcengine.QCEngineAdapter","text":"<pre><code>QCEngineAdapter(external_program: str)\n</code></pre> <p>Adapter for all programs supported by QCEngine.</p> Source code in <code>qcop/adapters/qcengine.py</code> <pre><code>def __init__(self, external_program: str) -&gt; None:\n    super().__init__()\n    self.external_program = external_program\n</code></pre>"},{"location":"programs/qcengine/#qcop.adapters.qcengine.QCEngineAdapter.supported_calctypes","title":"supported_calctypes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>supported_calctypes = [energy, gradient, hessian]\n</code></pre> <p>Supported calculation types.</p>"},{"location":"programs/qcengine/#qcop.adapters.qcengine.QCEngineAdapter.program_version","title":"program_version","text":"<pre><code>program_version(*args) -&gt; str\n</code></pre> <p>Get the program version.</p> Source code in <code>qcop/adapters/qcengine.py</code> <pre><code>def program_version(self, *args) -&gt; str:\n    \"\"\"Get the program version.\"\"\"\n    from qcengine import get_program\n    from qcengine.exceptions import QCEngineException\n\n    try:\n        adapter = get_program(self.external_program)\n        return adapter.get_version()\n    except QCEngineException as e:\n        raise ExternalProgramError(\n            program=self.program,\n            message=f\"QCEngine could not get version for program {self.external_program}.\",\n        ) from e\n</code></pre>"},{"location":"programs/terachem/","title":"TeraChem","text":""},{"location":"programs/terachem/#qcop.adapters.terachem.TeraChemAdapter","title":"qcop.adapters.terachem.TeraChemAdapter","text":"<p>Adapter for TeraChem.</p>"},{"location":"programs/terachem/#qcop.adapters.terachem.TeraChemAdapter.supported_calctypes","title":"supported_calctypes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>supported_calctypes = [\n    energy,\n    gradient,\n    hessian,\n    optimization,\n]\n</code></pre> <p>Supported calculation types.</p>"},{"location":"programs/terachem/#qcop.adapters.terachem.TeraChemAdapter.program_version","title":"program_version","text":"<pre><code>program_version(stdout: Optional[str] = None) -&gt; str\n</code></pre> <p>Get the program version.</p> <p>Parameters:</p> Name Type Description Default <code>stdout</code> <code>Optional[str]</code> <p>The stdout from the program.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The program version.</p> Source code in <code>qcop/adapters/terachem.py</code> <pre><code>def program_version(self, stdout: Optional[str] = None) -&gt; str:\n    \"\"\"Get the program version.\n\n    Args:\n        stdout: The stdout from the program.\n\n    Returns:\n        The program version.\n    \"\"\"\n    if stdout:\n        try:\n            return parse_version_string(stdout)\n        except qcparse_exceptions.ParserError:\n            # If the version string is not found. Happens when libcuda.so is not\n            # found and TeraChem fails to start. terachem --version will fail too.\n            return \"Could not parse version\"\n    else:\n        try:\n            return execute_subprocess(self.program, [\"--version\"])[17:]\n        except ExternalProgramError:\n            return \"Could not determine version\"\n</code></pre>"},{"location":"programs/terachem/#qcop.adapters.terachem.TeraChemAdapter.compute_results","title":"compute_results","text":"<pre><code>compute_results(\n    inp_obj: ProgramInput,\n    update_func: Optional[Callable] = None,\n    update_interval: Optional[float] = None,\n    **kwargs\n) -&gt; tuple[SinglePointResults, str]\n</code></pre> <p>Execute TeraChem on the given input.</p> <p>Parameters:</p> Name Type Description Default <code>inp_obj</code> <code>ProgramInput</code> <p>The qcio ProgramInput object for a computation.</p> required <code>update_func</code> <code>Optional[Callable]</code> <p>A callback function to call as the program executes.</p> <code>None</code> <code>update_interval</code> <code>Optional[float]</code> <p>The minimum time in seconds between calls to the update_func.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[SinglePointResults, str]</code> <p>A tuple of SinglePointResults and the stdout str.</p> Source code in <code>qcop/adapters/terachem.py</code> <pre><code>def compute_results(\n    self,\n    inp_obj: ProgramInput,\n    update_func: Optional[Callable] = None,\n    update_interval: Optional[float] = None,\n    **kwargs,\n) -&gt; tuple[SinglePointResults, str]:\n    \"\"\"Execute TeraChem on the given input.\n\n    Args:\n        inp_obj: The qcio ProgramInput object for a computation.\n        update_func: A callback function to call as the program executes.\n        update_interval: The minimum time in seconds between calls to the\n            update_func.\n\n    Returns:\n        A tuple of SinglePointResults and the stdout str.\n    \"\"\"\n    # Construct and write input file and xyz file to disk\n    try:\n        native_input = qcparse.encode(inp_obj, self.program)\n    except qcparse.exceptions.EncoderError as e:\n        raise AdapterInputError(program=self.program) from e\n\n    input_filename = \"tc.in\"\n    Path(input_filename).write_text(native_input.input_file)\n    Path(native_input.geometry_filename).write_text(native_input.geometry_file)\n\n    # Execute TeraChem\n    stdout = execute_subprocess(\n        self.program, [input_filename], update_func, update_interval\n    )\n\n    # Parse output\n    try:\n        if inp_obj.calctype == CalcType.optimization:\n            parsed_output = parse_optimization_dir(\n                f\"scr.{XYZ_FILENAME.split('.')[0]}\", stdout, inp_obj=inp_obj\n            )\n        else:\n            parsed_output = qcparse.parse(stdout, self.program, \"stdout\")\n    except qcparse_exceptions.ParserError as e:\n        raise ExternalProgramError(\n            program=\"qcparse\",\n            message=\"Failed to parse TeraChem output.\",\n            stdout=stdout,\n            original_exception=e,\n        ) from e\n    return parsed_output, stdout\n</code></pre>"},{"location":"programs/terachem/#qcop.adapters.terachem.TeraChemAdapter.collect_wfn","title":"collect_wfn","text":"<pre><code>collect_wfn() -&gt; dict[str, Union[str, bytes]]\n</code></pre> <p>Append wavefunction data to the output.</p> Source code in <code>qcop/adapters/terachem.py</code> <pre><code>def collect_wfn(self) -&gt; dict[str, Union[str, bytes]]:\n    \"\"\"Append wavefunction data to the output.\"\"\"\n\n    # Naming conventions from TeraChem uses xyz filename as scratch dir postfix\n    scr_postfix = XYZ_FILENAME.split(\".\")[0]\n\n    # Wavefunction filenames\n    wfn_filenames = (\"c0\", \"ca0\", \"cb0\")\n    wfn_paths = [Path(f\"scr.{scr_postfix}/{fn}\") for fn in wfn_filenames]\n    if not any(wfn_path.exists() for wfn_path in wfn_paths):\n        raise AdapterError(f\"No wavefunction files found in {Path.cwd()}\")\n\n    wfns: dict[str, Union[str, bytes]] = {}\n    for wfn_path in wfn_paths:\n        if wfn_path.exists():\n            wfns[str(wfn_path)] = wfn_path.read_bytes()\n    return wfns\n</code></pre>"},{"location":"programs/terachem/#qcop.adapters.terachem.TeraChemAdapter.propagate_wfn","title":"propagate_wfn","text":"<pre><code>propagate_wfn(\n    output: ProgramOutput, prog_inp: ProgramInput\n) -&gt; None\n</code></pre> <p>Propagate the wavefunction from the previous calculation.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>ProgramOutput</code> <p>The output from a previous calculation containing wavefunction data.</p> required <code>prog_inp</code> <code>ProgramInput</code> <p>The ProgramInput object on which to place the wavefunction data.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None. Modifies the prog_inp object in place.</p> Source code in <code>qcop/adapters/terachem.py</code> <pre><code>def propagate_wfn(self, output: ProgramOutput, prog_inp: ProgramInput) -&gt; None:\n    \"\"\"Propagate the wavefunction from the previous calculation.\n\n    Args:\n        output: The output from a previous calculation containing wavefunction data.\n        prog_inp: The ProgramInput object on which to place the wavefunction data.\n\n    Returns:\n        None. Modifies the prog_inp object in place.\n    \"\"\"\n\n    # Naming conventions from TeraChem uses xyz filename as scratch dir postfix\n    scr_postfix = XYZ_FILENAME.split(\".\")[0]\n\n    # Wavefunction filenames\n    c0, ca0, cb0 = \"c0\", \"ca0\", \"cb0\"\n\n    c0_bytes = output.results.files.get(f\"scr.{scr_postfix}/{c0}\")\n    ca0_bytes = output.results.files.get(f\"scr.{scr_postfix}/{ca0}\")\n    cb0_bytes = output.results.files.get(f\"scr.{scr_postfix}/{cb0}\")\n\n    if not c0_bytes and not (ca0_bytes and cb0_bytes):\n        raise AdapterInputError(\n            program=self.program,\n            message=\"Could not find c0 or ca/b0 files in output.\",\n        )\n\n    # Load wavefunction data onto ProgramInput object\n\n    if c0_bytes:\n        prog_inp.files[c0] = c0_bytes\n        prog_inp.keywords[\"guess\"] = c0\n\n    else:  # ca0_bytes and cb0_bytes\n        assert ca0_bytes and cb0_bytes  # for mypy\n        prog_inp.files[ca0] = ca0_bytes\n        prog_inp.files[cb0] = cb0_bytes\n        prog_inp.keywords[\"guess\"] = f\"{ca0} {cb0}\"\n</code></pre>"},{"location":"programs/terachem/#qcop.adapters.terachem_fe.TeraChemFEAdapter","title":"qcop.adapters.terachem_fe.TeraChemFEAdapter","text":"<pre><code>TeraChemFEAdapter()\n</code></pre> <p>Adapter for TeraChem's Protocol Buffer Server and Frontend file server.</p> Source code in <code>qcop/adapters/terachem_fe.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    # Check that xtb-python is installed.\n    self.tcpb = self._ensure_tcpb()\n    self.client = self.tcpb.TCFrontEndClient\n</code></pre>"},{"location":"programs/terachem/#qcop.adapters.terachem_fe.TeraChemFEAdapter.supported_calctypes","title":"supported_calctypes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>supported_calctypes = [energy, gradient]\n</code></pre> <p>Supported calculation types.</p>"},{"location":"programs/terachem/#qcop.adapters.terachem_fe.TeraChemFEAdapter.program_version","title":"program_version","text":"<pre><code>program_version(stdout: Optional[str] = None) -&gt; str\n</code></pre> <p>Program version is not available via the PB server.</p> Source code in <code>qcop/adapters/terachem_fe.py</code> <pre><code>def program_version(self, stdout: Optional[str] = None) -&gt; str:\n    \"\"\"Program version is not available via the PB server.\"\"\"\n    return \"\"\n</code></pre>"},{"location":"programs/terachem/#qcop.adapters.terachem_fe.TeraChemFEAdapter.compute_results","title":"compute_results","text":"<pre><code>compute_results(\n    inp_obj: ProgramInput,\n    update_func: Optional[Callable] = None,\n    update_interval: Optional[float] = None,\n    **kwargs\n) -&gt; tuple[SinglePointResults, str]\n</code></pre> <p>Execute TeraChem on the given input.</p> <p>Parameters:</p> Name Type Description Default <code>inp_obj</code> <code>ProgramInput</code> <p>The qcio ProgramInput object for a computation.</p> required <code>update_func</code> <code>Optional[Callable]</code> <p>A callback function to call as the program executes.</p> <code>None</code> <code>update_interval</code> <code>Optional[float]</code> <p>The minimum time in seconds between calls to the update_func.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[SinglePointResults, str]</code> <p>A tuple of SinglePointResults and the stdout str.</p> Source code in <code>qcop/adapters/terachem_fe.py</code> <pre><code>def compute_results(\n    self,\n    inp_obj: ProgramInput,\n    update_func: Optional[Callable] = None,\n    update_interval: Optional[float] = None,\n    **kwargs,\n) -&gt; tuple[SinglePointResults, str]:\n    \"\"\"Execute TeraChem on the given input.\n\n    Args:\n        inp_obj: The qcio ProgramInput object for a computation.\n        update_func: A callback function to call as the program executes.\n        update_interval: The minimum time in seconds between calls to the\n            update_func.\n\n    Returns:\n        A tuple of SinglePointResults and the stdout str.\n    \"\"\"\n    try:\n        with self.client() as client:\n            prog_output = client.compute(inp_obj)\n    except self.tcpb.exceptions.TCPBError as e:\n        exc = ExternalProgramError(\n            program=self.program,\n            # Pass stdout to .compute() via the exception\n            # Will only exist for TeraChemFrontendAdapter\n            stdout=e.program_output.stdout,\n        )\n\n        raise exc\n\n    else:\n        # Write files to disk to be collected by BaseAdapter.compute()\n        # Used only for TeraChemFrontendAdapter\n        prog_output.results.save_files()\n\n    return prog_output.results, prog_output.stdout\n</code></pre>"},{"location":"programs/terachem/#qcop.adapters.terachem_pbs.TeraChemPBSAdapter","title":"qcop.adapters.terachem_pbs.TeraChemPBSAdapter","text":"<pre><code>TeraChemPBSAdapter()\n</code></pre> <p>Adapter for TeraChem's Protocol Buffer Server.</p> Source code in <code>qcop/adapters/terachem_pbs.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    # Check that xtb-python is installed.\n    self.tcpb = self._ensure_tcpb()\n    self.client = self.tcpb.TCProtobufClient\n</code></pre>"},{"location":"programs/xtb/","title":"xtb","text":""},{"location":"programs/xtb/#qcop.adapters.xtb.XTBAdapter","title":"qcop.adapters.xtb.XTBAdapter","text":"<pre><code>XTBAdapter()\n</code></pre> <p>Adapter for xtb-python.</p> Source code in <code>qcop/adapters/xtb.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    # Check that xtb-python is installed.\n    self.xtb = self._ensure_xtb()\n</code></pre>"},{"location":"programs/xtb/#qcop.adapters.xtb.XTBAdapter.supported_calctypes","title":"supported_calctypes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>supported_calctypes = [energy, gradient]\n</code></pre> <p>Supported calculation types.</p>"},{"location":"programs/xtb/#qcop.adapters.xtb.XTBAdapter.validate_input","title":"validate_input","text":"<pre><code>validate_input(inp_obj: ProgramInput) -&gt; None\n</code></pre> <p>Validate the input for xtb-python.</p> Source code in <code>qcop/adapters/xtb.py</code> <pre><code>def validate_input(self, inp_obj: ProgramInput) -&gt; None:\n    \"\"\"Validate the input for xtb-python.\"\"\"\n    super().validate_input(inp_obj)\n    # Check that xtb supports the method.\n    supported_methods = self.xtb.interface.Param.__members__.keys()\n    if inp_obj.model.method not in supported_methods:\n        raise AdapterInputError(\n            program=self.program,\n            message=f\"Unsupported method '{inp_obj.model.method}'. \"\n            f\"Supported methods include: {supported_methods}\",\n        )\n</code></pre>"},{"location":"programs/xtb/#qcop.adapters.xtb.XTBAdapter.program_version","title":"program_version","text":"<pre><code>program_version(stdout: Optional[str] = None) -&gt; str\n</code></pre> <p>Get the program version.</p> <p>Parameters:</p> Name Type Description Default <code>stdout</code> <code>Optional[str]</code> <p>The stdout from the program.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The program version.</p> Source code in <code>qcop/adapters/xtb.py</code> <pre><code>def program_version(self, stdout: Optional[str] = None) -&gt; str:\n    \"\"\"Get the program version.\n\n    Args:\n        stdout: The stdout from the program.\n\n    Returns:\n        The program version.\n    \"\"\"\n    global CACHED_XTB_VERSION\n    if not CACHED_XTB_VERSION:\n        CACHED_XTB_VERSION = importlib.metadata.version(self.program)\n    return CACHED_XTB_VERSION\n</code></pre>"},{"location":"programs/xtb/#qcop.adapters.xtb.XTBAdapter.compute_results","title":"compute_results","text":"<pre><code>compute_results(\n    inp_obj: ProgramInput,\n    update_func: Optional[Callable] = None,\n    update_interval: Optional[float] = None,\n    **kwargs\n) -&gt; tuple[SinglePointResults, str]\n</code></pre> <p>Execute xtb on the given input.</p> <p>Parameters:</p> Name Type Description Default <code>inp_obj</code> <code>ProgramInput</code> <p>The qcio ProgramInput object for a computation.</p> required <code>update_func</code> <code>Optional[Callable]</code> <p>A callback function to call as the program executes.</p> <code>None</code> <code>update_interval</code> <code>Optional[float]</code> <p>The minimum time in seconds between calls to the update_func.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[SinglePointResults, str]</code> <p>A tuple of SinglePointComputedProps and the stdout str.</p> Source code in <code>qcop/adapters/xtb.py</code> <pre><code>def compute_results(\n    self,\n    inp_obj: ProgramInput,\n    update_func: Optional[Callable] = None,\n    update_interval: Optional[float] = None,\n    **kwargs,\n) -&gt; tuple[SinglePointResults, str]:\n    \"\"\"Execute xtb on the given input.\n\n    Args:\n        inp_obj: The qcio ProgramInput object for a computation.\n        update_func: A callback function to call as the program executes.\n        update_interval: The minimum time in seconds between calls to the\n            update_func.\n\n    Returns:\n        A tuple of SinglePointComputedProps and the stdout str.\n    \"\"\"\n    try:\n        # Create Calculator\n        calc = self.xtb.interface.Calculator(\n            getattr(self.xtb.interface.Param, inp_obj.model.method),\n            np.array(inp_obj.structure.atomic_numbers),\n            inp_obj.structure.geometry,\n            inp_obj.structure.charge,\n            # From https://github.com/grimme-lab/xtb-python/blob/a32309a43e5a6572b033814eacf396328a2a36ed/xtb/qcschema/harness.py#L126 # noqa: E501\n            inp_obj.structure.multiplicity - 1,\n        )\n        calc.set_verbosity(self.xtb.libxtb.VERBOSITY_FULL)  # all logs\n\n        # Set Keywords\n        for key, value in inp_obj.keywords.items():\n            # TODO: Need to handle external_charges and solvent\n            getattr(calc, f\"set_{key}\")(value)\n\n        # Capture logs\n        with capture_sys_stdout() as r_pipe:\n            res = calc.singlepoint()\n            # Not sure what this does but it's in the xtb-python docs\n            calc.release_output()\n            stdout = os.read(r_pipe, 100000).decode()\n\n    except self.xtb.interface.XTBException as e:\n        raise ExternalProgramError(program=\"xtb-python\") from e\n\n    # Collect results\n    # TODO: Collect other results xtb produces\n    results = SinglePointResults(\n        energy=res.get_energy(),\n        gradient=res.get_gradient(),\n        scf_dipole_moment=res.get_dipole(),\n        wavefunction=Wavefunction(\n            scf_eigenvalues_a=res.get_orbital_eigenvalues(),\n        ),\n    )\n\n    return results, stdout\n</code></pre>"},{"location":"programs/xtb/#example","title":"Example","text":"<pre><code>\"\"\"Must run script like this: python -m examples.xtb\"\"\"\n\nfrom qcio import CalcType, ProgramInput, Structure\n\nfrom qcop import compute\n\n# Create the structure\n# Can also open a structure from a file\n# structure = Structure.open(\"path/to/h2o.xyz\")\nstructure = Structure(\n    symbols=[\"O\", \"H\", \"H\"],\n    geometry=[  # type: ignore\n        [0.0, 0.0, 0.0],\n        [0.52421003, 1.68733646, 0.48074633],\n        [1.14668581, -0.45032174, -1.35474466],\n    ],\n)\n\n# Define the program input\nprog_input = ProgramInput(\n    structure=structure,\n    calctype=CalcType.energy,\n    model={\"method\": \"GFN2xTB\"},  # type: ignore\n    keywords={\"max_iterations\": 150},\n)\n\n\nprog_output = compute(\"xtb\", prog_input)\nprint(prog_output)\n</code></pre>"}]}